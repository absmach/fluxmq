// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.0
// source: broker.proto

package grpc

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// PublishRequest contains a serialized PUBLISH packet to route to a client.
type PublishRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`                                                               // Target client ID
	Topic         string                 `protobuf:"bytes,2,opt,name=topic,proto3" json:"topic,omitempty"`                                                                                     // MQTT topic
	Payload       []byte                 `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`                                                                                 // Message payload
	Qos           uint32                 `protobuf:"varint,4,opt,name=qos,proto3" json:"qos,omitempty"`                                                                                        // QoS level (0, 1, 2)
	Retain        bool                   `protobuf:"varint,5,opt,name=retain,proto3" json:"retain,omitempty"`                                                                                  // Retain flag
	Dup           bool                   `protobuf:"varint,6,opt,name=dup,proto3" json:"dup,omitempty"`                                                                                        // Duplicate flag
	Properties    map[string]string      `protobuf:"bytes,7,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // MQTT v5 properties (if any)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublishRequest) Reset() {
	*x = PublishRequest{}
	mi := &file_broker_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublishRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublishRequest) ProtoMessage() {}

func (x *PublishRequest) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublishRequest.ProtoReflect.Descriptor instead.
func (*PublishRequest) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{0}
}

func (x *PublishRequest) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *PublishRequest) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *PublishRequest) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *PublishRequest) GetQos() uint32 {
	if x != nil {
		return x.Qos
	}
	return 0
}

func (x *PublishRequest) GetRetain() bool {
	if x != nil {
		return x.Retain
	}
	return false
}

func (x *PublishRequest) GetDup() bool {
	if x != nil {
		return x.Dup
	}
	return false
}

func (x *PublishRequest) GetProperties() map[string]string {
	if x != nil {
		return x.Properties
	}
	return nil
}

// PublishResponse indicates whether the publish was delivered.
type PublishResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"` // Error message if success=false
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublishResponse) Reset() {
	*x = PublishResponse{}
	mi := &file_broker_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublishResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublishResponse) ProtoMessage() {}

func (x *PublishResponse) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublishResponse.ProtoReflect.Descriptor instead.
func (*PublishResponse) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{1}
}

func (x *PublishResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *PublishResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// TakeoverRequest requests session migration from one node to another.
type TakeoverRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	FromNode      string                 `protobuf:"bytes,2,opt,name=from_node,json=fromNode,proto3" json:"from_node,omitempty"` // Node currently owning the session
	ToNode        string                 `protobuf:"bytes,3,opt,name=to_node,json=toNode,proto3" json:"to_node,omitempty"`       // Node taking over the session
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TakeoverRequest) Reset() {
	*x = TakeoverRequest{}
	mi := &file_broker_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TakeoverRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TakeoverRequest) ProtoMessage() {}

func (x *TakeoverRequest) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TakeoverRequest.ProtoReflect.Descriptor instead.
func (*TakeoverRequest) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{2}
}

func (x *TakeoverRequest) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *TakeoverRequest) GetFromNode() string {
	if x != nil {
		return x.FromNode
	}
	return ""
}

func (x *TakeoverRequest) GetToNode() string {
	if x != nil {
		return x.ToNode
	}
	return ""
}

// SessionState contains the full state of an MQTT session.
type SessionState struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	ExpiryInterval uint32                 `protobuf:"varint,1,opt,name=expiry_interval,json=expiryInterval,proto3" json:"expiry_interval,omitempty"`
	CleanStart     bool                   `protobuf:"varint,2,opt,name=clean_start,json=cleanStart,proto3" json:"clean_start,omitempty"`
	// In-flight messages (QoS 1/2 not yet acknowledged)
	InflightMessages []*InflightMessage `protobuf:"bytes,3,rep,name=inflight_messages,json=inflightMessages,proto3" json:"inflight_messages,omitempty"`
	// Offline queue (messages waiting for delivery)
	QueuedMessages []*QueuedMessage `protobuf:"bytes,4,rep,name=queued_messages,json=queuedMessages,proto3" json:"queued_messages,omitempty"`
	// Subscriptions
	Subscriptions []*Subscription `protobuf:"bytes,5,rep,name=subscriptions,proto3" json:"subscriptions,omitempty"`
	// Will message
	Will          *WillMessage `protobuf:"bytes,6,opt,name=will,proto3" json:"will,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SessionState) Reset() {
	*x = SessionState{}
	mi := &file_broker_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SessionState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionState) ProtoMessage() {}

func (x *SessionState) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionState.ProtoReflect.Descriptor instead.
func (*SessionState) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{3}
}

func (x *SessionState) GetExpiryInterval() uint32 {
	if x != nil {
		return x.ExpiryInterval
	}
	return 0
}

func (x *SessionState) GetCleanStart() bool {
	if x != nil {
		return x.CleanStart
	}
	return false
}

func (x *SessionState) GetInflightMessages() []*InflightMessage {
	if x != nil {
		return x.InflightMessages
	}
	return nil
}

func (x *SessionState) GetQueuedMessages() []*QueuedMessage {
	if x != nil {
		return x.QueuedMessages
	}
	return nil
}

func (x *SessionState) GetSubscriptions() []*Subscription {
	if x != nil {
		return x.Subscriptions
	}
	return nil
}

func (x *SessionState) GetWill() *WillMessage {
	if x != nil {
		return x.Will
	}
	return nil
}

// InflightMessage represents a message awaiting acknowledgment.
type InflightMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PacketId      uint32                 `protobuf:"varint,1,opt,name=packet_id,json=packetId,proto3" json:"packet_id,omitempty"`
	Topic         string                 `protobuf:"bytes,2,opt,name=topic,proto3" json:"topic,omitempty"`
	Payload       []byte                 `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	Qos           uint32                 `protobuf:"varint,4,opt,name=qos,proto3" json:"qos,omitempty"`
	Retain        bool                   `protobuf:"varint,5,opt,name=retain,proto3" json:"retain,omitempty"`
	Timestamp     int64                  `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InflightMessage) Reset() {
	*x = InflightMessage{}
	mi := &file_broker_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InflightMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InflightMessage) ProtoMessage() {}

func (x *InflightMessage) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InflightMessage.ProtoReflect.Descriptor instead.
func (*InflightMessage) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{4}
}

func (x *InflightMessage) GetPacketId() uint32 {
	if x != nil {
		return x.PacketId
	}
	return 0
}

func (x *InflightMessage) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *InflightMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *InflightMessage) GetQos() uint32 {
	if x != nil {
		return x.Qos
	}
	return 0
}

func (x *InflightMessage) GetRetain() bool {
	if x != nil {
		return x.Retain
	}
	return false
}

func (x *InflightMessage) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// QueuedMessage represents a message in the offline queue.
type QueuedMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Topic         string                 `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Payload       []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	Qos           uint32                 `protobuf:"varint,3,opt,name=qos,proto3" json:"qos,omitempty"`
	Retain        bool                   `protobuf:"varint,4,opt,name=retain,proto3" json:"retain,omitempty"`
	Timestamp     int64                  `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueuedMessage) Reset() {
	*x = QueuedMessage{}
	mi := &file_broker_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueuedMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueuedMessage) ProtoMessage() {}

func (x *QueuedMessage) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueuedMessage.ProtoReflect.Descriptor instead.
func (*QueuedMessage) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{5}
}

func (x *QueuedMessage) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *QueuedMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *QueuedMessage) GetQos() uint32 {
	if x != nil {
		return x.Qos
	}
	return 0
}

func (x *QueuedMessage) GetRetain() bool {
	if x != nil {
		return x.Retain
	}
	return false
}

func (x *QueuedMessage) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// Subscription represents a topic subscription.
type Subscription struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Filter        string                 `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	Qos           uint32                 `protobuf:"varint,2,opt,name=qos,proto3" json:"qos,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Subscription) Reset() {
	*x = Subscription{}
	mi := &file_broker_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Subscription) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Subscription) ProtoMessage() {}

func (x *Subscription) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Subscription.ProtoReflect.Descriptor instead.
func (*Subscription) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{6}
}

func (x *Subscription) GetFilter() string {
	if x != nil {
		return x.Filter
	}
	return ""
}

func (x *Subscription) GetQos() uint32 {
	if x != nil {
		return x.Qos
	}
	return 0
}

// WillMessage represents a last will and testament.
type WillMessage struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Topic          string                 `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Payload        []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	Qos            uint32                 `protobuf:"varint,3,opt,name=qos,proto3" json:"qos,omitempty"`
	Retain         bool                   `protobuf:"varint,4,opt,name=retain,proto3" json:"retain,omitempty"`
	Delay          uint32                 `protobuf:"varint,5,opt,name=delay,proto3" json:"delay,omitempty"`
	DisconnectTime int64                  `protobuf:"varint,6,opt,name=disconnect_time,json=disconnectTime,proto3" json:"disconnect_time,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *WillMessage) Reset() {
	*x = WillMessage{}
	mi := &file_broker_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WillMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WillMessage) ProtoMessage() {}

func (x *WillMessage) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WillMessage.ProtoReflect.Descriptor instead.
func (*WillMessage) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{7}
}

func (x *WillMessage) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *WillMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *WillMessage) GetQos() uint32 {
	if x != nil {
		return x.Qos
	}
	return 0
}

func (x *WillMessage) GetRetain() bool {
	if x != nil {
		return x.Retain
	}
	return false
}

func (x *WillMessage) GetDelay() uint32 {
	if x != nil {
		return x.Delay
	}
	return 0
}

func (x *WillMessage) GetDisconnectTime() int64 {
	if x != nil {
		return x.DisconnectTime
	}
	return 0
}

// TakeoverResponse indicates whether the takeover succeeded and returns session state.
type TakeoverResponse struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Success bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error   string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Session state transferred from the old node
	SessionState  *SessionState `protobuf:"bytes,3,opt,name=session_state,json=sessionState,proto3" json:"session_state,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TakeoverResponse) Reset() {
	*x = TakeoverResponse{}
	mi := &file_broker_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TakeoverResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TakeoverResponse) ProtoMessage() {}

func (x *TakeoverResponse) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TakeoverResponse.ProtoReflect.Descriptor instead.
func (*TakeoverResponse) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{8}
}

func (x *TakeoverResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *TakeoverResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *TakeoverResponse) GetSessionState() *SessionState {
	if x != nil {
		return x.SessionState
	}
	return nil
}

// FetchRetainedRequest requests a retained message from the owning node.
type FetchRetainedRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Topic         string                 `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"` // Topic of the retained message to fetch
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FetchRetainedRequest) Reset() {
	*x = FetchRetainedRequest{}
	mi := &file_broker_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetchRetainedRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchRetainedRequest) ProtoMessage() {}

func (x *FetchRetainedRequest) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchRetainedRequest.ProtoReflect.Descriptor instead.
func (*FetchRetainedRequest) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{9}
}

func (x *FetchRetainedRequest) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

// RetainedMessage represents a complete retained message with all properties.
type RetainedMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Topic         string                 `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Payload       []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	Qos           uint32                 `protobuf:"varint,3,opt,name=qos,proto3" json:"qos,omitempty"`
	Retain        bool                   `protobuf:"varint,4,opt,name=retain,proto3" json:"retain,omitempty"`
	Properties    map[string]string      `protobuf:"bytes,5,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // MQTT v5 properties
	Timestamp     int64                  `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`                                                                            // When the message was retained
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RetainedMessage) Reset() {
	*x = RetainedMessage{}
	mi := &file_broker_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RetainedMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetainedMessage) ProtoMessage() {}

func (x *RetainedMessage) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RetainedMessage.ProtoReflect.Descriptor instead.
func (*RetainedMessage) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{10}
}

func (x *RetainedMessage) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *RetainedMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *RetainedMessage) GetQos() uint32 {
	if x != nil {
		return x.Qos
	}
	return 0
}

func (x *RetainedMessage) GetRetain() bool {
	if x != nil {
		return x.Retain
	}
	return false
}

func (x *RetainedMessage) GetProperties() map[string]string {
	if x != nil {
		return x.Properties
	}
	return nil
}

func (x *RetainedMessage) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// FetchRetainedResponse returns the retained message if found.
type FetchRetainedResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Found         bool                   `protobuf:"varint,1,opt,name=found,proto3" json:"found,omitempty"`    // True if message exists
	Message       *RetainedMessage       `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"` // The retained message (only if found=true)
	Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`     // Error message if request failed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FetchRetainedResponse) Reset() {
	*x = FetchRetainedResponse{}
	mi := &file_broker_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetchRetainedResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchRetainedResponse) ProtoMessage() {}

func (x *FetchRetainedResponse) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchRetainedResponse.ProtoReflect.Descriptor instead.
func (*FetchRetainedResponse) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{11}
}

func (x *FetchRetainedResponse) GetFound() bool {
	if x != nil {
		return x.Found
	}
	return false
}

func (x *FetchRetainedResponse) GetMessage() *RetainedMessage {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *FetchRetainedResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// FetchWillRequest requests a will message from the owning node.
type FetchWillRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"` // Client ID whose will message to fetch
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FetchWillRequest) Reset() {
	*x = FetchWillRequest{}
	mi := &file_broker_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetchWillRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchWillRequest) ProtoMessage() {}

func (x *FetchWillRequest) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchWillRequest.ProtoReflect.Descriptor instead.
func (*FetchWillRequest) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{12}
}

func (x *FetchWillRequest) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

// FetchWillResponse returns the will message if found.
type FetchWillResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Found         bool                   `protobuf:"varint,1,opt,name=found,proto3" json:"found,omitempty"`    // True if will message exists
	Message       *WillMessage           `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"` // The will message (only if found=true)
	Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`     // Error message if request failed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FetchWillResponse) Reset() {
	*x = FetchWillResponse{}
	mi := &file_broker_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetchWillResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchWillResponse) ProtoMessage() {}

func (x *FetchWillResponse) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchWillResponse.ProtoReflect.Descriptor instead.
func (*FetchWillResponse) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{13}
}

func (x *FetchWillResponse) GetFound() bool {
	if x != nil {
		return x.Found
	}
	return false
}

func (x *FetchWillResponse) GetMessage() *WillMessage {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *FetchWillResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

var File_broker_proto protoreflect.FileDescriptor

const file_broker_proto_rawDesc = "" +
	"\n" +
	"\fbroker.proto\x12\acluster\"\xa1\x02\n" +
	"\x0ePublishRequest\x12\x1b\n" +
	"\tclient_id\x18\x01 \x01(\tR\bclientId\x12\x14\n" +
	"\x05topic\x18\x02 \x01(\tR\x05topic\x12\x18\n" +
	"\apayload\x18\x03 \x01(\fR\apayload\x12\x10\n" +
	"\x03qos\x18\x04 \x01(\rR\x03qos\x12\x16\n" +
	"\x06retain\x18\x05 \x01(\bR\x06retain\x12\x10\n" +
	"\x03dup\x18\x06 \x01(\bR\x03dup\x12G\n" +
	"\n" +
	"properties\x18\a \x03(\v2'.cluster.PublishRequest.PropertiesEntryR\n" +
	"properties\x1a=\n" +
	"\x0fPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"A\n" +
	"\x0fPublishResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"d\n" +
	"\x0fTakeoverRequest\x12\x1b\n" +
	"\tclient_id\x18\x01 \x01(\tR\bclientId\x12\x1b\n" +
	"\tfrom_node\x18\x02 \x01(\tR\bfromNode\x12\x17\n" +
	"\ato_node\x18\x03 \x01(\tR\x06toNode\"\xc7\x02\n" +
	"\fSessionState\x12'\n" +
	"\x0fexpiry_interval\x18\x01 \x01(\rR\x0eexpiryInterval\x12\x1f\n" +
	"\vclean_start\x18\x02 \x01(\bR\n" +
	"cleanStart\x12E\n" +
	"\x11inflight_messages\x18\x03 \x03(\v2\x18.cluster.InflightMessageR\x10inflightMessages\x12?\n" +
	"\x0fqueued_messages\x18\x04 \x03(\v2\x16.cluster.QueuedMessageR\x0equeuedMessages\x12;\n" +
	"\rsubscriptions\x18\x05 \x03(\v2\x15.cluster.SubscriptionR\rsubscriptions\x12(\n" +
	"\x04will\x18\x06 \x01(\v2\x14.cluster.WillMessageR\x04will\"\xa6\x01\n" +
	"\x0fInflightMessage\x12\x1b\n" +
	"\tpacket_id\x18\x01 \x01(\rR\bpacketId\x12\x14\n" +
	"\x05topic\x18\x02 \x01(\tR\x05topic\x12\x18\n" +
	"\apayload\x18\x03 \x01(\fR\apayload\x12\x10\n" +
	"\x03qos\x18\x04 \x01(\rR\x03qos\x12\x16\n" +
	"\x06retain\x18\x05 \x01(\bR\x06retain\x12\x1c\n" +
	"\ttimestamp\x18\x06 \x01(\x03R\ttimestamp\"\x87\x01\n" +
	"\rQueuedMessage\x12\x14\n" +
	"\x05topic\x18\x01 \x01(\tR\x05topic\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayload\x12\x10\n" +
	"\x03qos\x18\x03 \x01(\rR\x03qos\x12\x16\n" +
	"\x06retain\x18\x04 \x01(\bR\x06retain\x12\x1c\n" +
	"\ttimestamp\x18\x05 \x01(\x03R\ttimestamp\"8\n" +
	"\fSubscription\x12\x16\n" +
	"\x06filter\x18\x01 \x01(\tR\x06filter\x12\x10\n" +
	"\x03qos\x18\x02 \x01(\rR\x03qos\"\xa6\x01\n" +
	"\vWillMessage\x12\x14\n" +
	"\x05topic\x18\x01 \x01(\tR\x05topic\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayload\x12\x10\n" +
	"\x03qos\x18\x03 \x01(\rR\x03qos\x12\x16\n" +
	"\x06retain\x18\x04 \x01(\bR\x06retain\x12\x14\n" +
	"\x05delay\x18\x05 \x01(\rR\x05delay\x12'\n" +
	"\x0fdisconnect_time\x18\x06 \x01(\x03R\x0edisconnectTime\"~\n" +
	"\x10TakeoverResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12:\n" +
	"\rsession_state\x18\x03 \x01(\v2\x15.cluster.SessionStateR\fsessionState\",\n" +
	"\x14FetchRetainedRequest\x12\x14\n" +
	"\x05topic\x18\x01 \x01(\tR\x05topic\"\x92\x02\n" +
	"\x0fRetainedMessage\x12\x14\n" +
	"\x05topic\x18\x01 \x01(\tR\x05topic\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayload\x12\x10\n" +
	"\x03qos\x18\x03 \x01(\rR\x03qos\x12\x16\n" +
	"\x06retain\x18\x04 \x01(\bR\x06retain\x12H\n" +
	"\n" +
	"properties\x18\x05 \x03(\v2(.cluster.RetainedMessage.PropertiesEntryR\n" +
	"properties\x12\x1c\n" +
	"\ttimestamp\x18\x06 \x01(\x03R\ttimestamp\x1a=\n" +
	"\x0fPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"w\n" +
	"\x15FetchRetainedResponse\x12\x14\n" +
	"\x05found\x18\x01 \x01(\bR\x05found\x122\n" +
	"\amessage\x18\x02 \x01(\v2\x18.cluster.RetainedMessageR\amessage\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"/\n" +
	"\x10FetchWillRequest\x12\x1b\n" +
	"\tclient_id\x18\x01 \x01(\tR\bclientId\"o\n" +
	"\x11FetchWillResponse\x12\x14\n" +
	"\x05found\x18\x01 \x01(\bR\x05found\x12.\n" +
	"\amessage\x18\x02 \x01(\v2\x14.cluster.WillMessageR\amessage\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error2\xae\x02\n" +
	"\rBrokerService\x12A\n" +
	"\fRoutePublish\x12\x17.cluster.PublishRequest\x1a\x18.cluster.PublishResponse\x12F\n" +
	"\x0fTakeoverSession\x12\x18.cluster.TakeoverRequest\x1a\x19.cluster.TakeoverResponse\x12N\n" +
	"\rFetchRetained\x12\x1d.cluster.FetchRetainedRequest\x1a\x1e.cluster.FetchRetainedResponse\x12B\n" +
	"\tFetchWill\x12\x19.cluster.FetchWillRequest\x1a\x1a.cluster.FetchWillResponseB&Z$github.com/absmach/mqtt/cluster/grpcb\x06proto3"

var (
	file_broker_proto_rawDescOnce sync.Once
	file_broker_proto_rawDescData []byte
)

func file_broker_proto_rawDescGZIP() []byte {
	file_broker_proto_rawDescOnce.Do(func() {
		file_broker_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_broker_proto_rawDesc), len(file_broker_proto_rawDesc)))
	})
	return file_broker_proto_rawDescData
}

var file_broker_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_broker_proto_goTypes = []any{
	(*PublishRequest)(nil),        // 0: cluster.PublishRequest
	(*PublishResponse)(nil),       // 1: cluster.PublishResponse
	(*TakeoverRequest)(nil),       // 2: cluster.TakeoverRequest
	(*SessionState)(nil),          // 3: cluster.SessionState
	(*InflightMessage)(nil),       // 4: cluster.InflightMessage
	(*QueuedMessage)(nil),         // 5: cluster.QueuedMessage
	(*Subscription)(nil),          // 6: cluster.Subscription
	(*WillMessage)(nil),           // 7: cluster.WillMessage
	(*TakeoverResponse)(nil),      // 8: cluster.TakeoverResponse
	(*FetchRetainedRequest)(nil),  // 9: cluster.FetchRetainedRequest
	(*RetainedMessage)(nil),       // 10: cluster.RetainedMessage
	(*FetchRetainedResponse)(nil), // 11: cluster.FetchRetainedResponse
	(*FetchWillRequest)(nil),      // 12: cluster.FetchWillRequest
	(*FetchWillResponse)(nil),     // 13: cluster.FetchWillResponse
	nil,                           // 14: cluster.PublishRequest.PropertiesEntry
	nil,                           // 15: cluster.RetainedMessage.PropertiesEntry
}
var file_broker_proto_depIdxs = []int32{
	14, // 0: cluster.PublishRequest.properties:type_name -> cluster.PublishRequest.PropertiesEntry
	4,  // 1: cluster.SessionState.inflight_messages:type_name -> cluster.InflightMessage
	5,  // 2: cluster.SessionState.queued_messages:type_name -> cluster.QueuedMessage
	6,  // 3: cluster.SessionState.subscriptions:type_name -> cluster.Subscription
	7,  // 4: cluster.SessionState.will:type_name -> cluster.WillMessage
	3,  // 5: cluster.TakeoverResponse.session_state:type_name -> cluster.SessionState
	15, // 6: cluster.RetainedMessage.properties:type_name -> cluster.RetainedMessage.PropertiesEntry
	10, // 7: cluster.FetchRetainedResponse.message:type_name -> cluster.RetainedMessage
	7,  // 8: cluster.FetchWillResponse.message:type_name -> cluster.WillMessage
	0,  // 9: cluster.BrokerService.RoutePublish:input_type -> cluster.PublishRequest
	2,  // 10: cluster.BrokerService.TakeoverSession:input_type -> cluster.TakeoverRequest
	9,  // 11: cluster.BrokerService.FetchRetained:input_type -> cluster.FetchRetainedRequest
	12, // 12: cluster.BrokerService.FetchWill:input_type -> cluster.FetchWillRequest
	1,  // 13: cluster.BrokerService.RoutePublish:output_type -> cluster.PublishResponse
	8,  // 14: cluster.BrokerService.TakeoverSession:output_type -> cluster.TakeoverResponse
	11, // 15: cluster.BrokerService.FetchRetained:output_type -> cluster.FetchRetainedResponse
	13, // 16: cluster.BrokerService.FetchWill:output_type -> cluster.FetchWillResponse
	13, // [13:17] is the sub-list for method output_type
	9,  // [9:13] is the sub-list for method input_type
	9,  // [9:9] is the sub-list for extension type_name
	9,  // [9:9] is the sub-list for extension extendee
	0,  // [0:9] is the sub-list for field type_name
}

func init() { file_broker_proto_init() }
func file_broker_proto_init() {
	if File_broker_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_broker_proto_rawDesc), len(file_broker_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_broker_proto_goTypes,
		DependencyIndexes: file_broker_proto_depIdxs,
		MessageInfos:      file_broker_proto_msgTypes,
	}.Build()
	File_broker_proto = out.File
	file_broker_proto_goTypes = nil
	file_broker_proto_depIdxs = nil
}
