// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.33.0
// source: broker.proto

package grpc

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// PublishRequest contains a serialized PUBLISH packet to route to a client.
type PublishRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`                                                               // Target client ID
	Topic         string                 `protobuf:"bytes,2,opt,name=topic,proto3" json:"topic,omitempty"`                                                                                     // MQTT topic
	Payload       []byte                 `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`                                                                                 // Message payload
	Qos           uint32                 `protobuf:"varint,4,opt,name=qos,proto3" json:"qos,omitempty"`                                                                                        // QoS level (0, 1, 2)
	Retain        bool                   `protobuf:"varint,5,opt,name=retain,proto3" json:"retain,omitempty"`                                                                                  // Retain flag
	Dup           bool                   `protobuf:"varint,6,opt,name=dup,proto3" json:"dup,omitempty"`                                                                                        // Duplicate flag
	Properties    map[string]string      `protobuf:"bytes,7,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // MQTT v5 properties (if any)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublishRequest) Reset() {
	*x = PublishRequest{}
	mi := &file_broker_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublishRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublishRequest) ProtoMessage() {}

func (x *PublishRequest) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublishRequest.ProtoReflect.Descriptor instead.
func (*PublishRequest) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{0}
}

func (x *PublishRequest) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *PublishRequest) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *PublishRequest) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *PublishRequest) GetQos() uint32 {
	if x != nil {
		return x.Qos
	}
	return 0
}

func (x *PublishRequest) GetRetain() bool {
	if x != nil {
		return x.Retain
	}
	return false
}

func (x *PublishRequest) GetDup() bool {
	if x != nil {
		return x.Dup
	}
	return false
}

func (x *PublishRequest) GetProperties() map[string]string {
	if x != nil {
		return x.Properties
	}
	return nil
}

// PublishResponse indicates whether the publish was delivered.
type PublishResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"` // Error message if success=false
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublishResponse) Reset() {
	*x = PublishResponse{}
	mi := &file_broker_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublishResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublishResponse) ProtoMessage() {}

func (x *PublishResponse) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublishResponse.ProtoReflect.Descriptor instead.
func (*PublishResponse) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{1}
}

func (x *PublishResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *PublishResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// TakeoverRequest requests session migration from one node to another.
type TakeoverRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	FromNode      string                 `protobuf:"bytes,2,opt,name=from_node,json=fromNode,proto3" json:"from_node,omitempty"` // Node currently owning the session
	ToNode        string                 `protobuf:"bytes,3,opt,name=to_node,json=toNode,proto3" json:"to_node,omitempty"`       // Node taking over the session
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TakeoverRequest) Reset() {
	*x = TakeoverRequest{}
	mi := &file_broker_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TakeoverRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TakeoverRequest) ProtoMessage() {}

func (x *TakeoverRequest) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TakeoverRequest.ProtoReflect.Descriptor instead.
func (*TakeoverRequest) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{2}
}

func (x *TakeoverRequest) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *TakeoverRequest) GetFromNode() string {
	if x != nil {
		return x.FromNode
	}
	return ""
}

func (x *TakeoverRequest) GetToNode() string {
	if x != nil {
		return x.ToNode
	}
	return ""
}

// SessionState contains the full state of an MQTT session.
type SessionState struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	ExpiryInterval uint32                 `protobuf:"varint,1,opt,name=expiry_interval,json=expiryInterval,proto3" json:"expiry_interval,omitempty"`
	CleanStart     bool                   `protobuf:"varint,2,opt,name=clean_start,json=cleanStart,proto3" json:"clean_start,omitempty"`
	// In-flight messages (QoS 1/2 not yet acknowledged)
	InflightMessages []*InflightMessage `protobuf:"bytes,3,rep,name=inflight_messages,json=inflightMessages,proto3" json:"inflight_messages,omitempty"`
	// Offline queue (messages waiting for delivery)
	QueuedMessages []*QueuedMessage `protobuf:"bytes,4,rep,name=queued_messages,json=queuedMessages,proto3" json:"queued_messages,omitempty"`
	// Subscriptions
	Subscriptions []*Subscription `protobuf:"bytes,5,rep,name=subscriptions,proto3" json:"subscriptions,omitempty"`
	// Will message
	Will          *WillMessage `protobuf:"bytes,6,opt,name=will,proto3" json:"will,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SessionState) Reset() {
	*x = SessionState{}
	mi := &file_broker_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SessionState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SessionState) ProtoMessage() {}

func (x *SessionState) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SessionState.ProtoReflect.Descriptor instead.
func (*SessionState) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{3}
}

func (x *SessionState) GetExpiryInterval() uint32 {
	if x != nil {
		return x.ExpiryInterval
	}
	return 0
}

func (x *SessionState) GetCleanStart() bool {
	if x != nil {
		return x.CleanStart
	}
	return false
}

func (x *SessionState) GetInflightMessages() []*InflightMessage {
	if x != nil {
		return x.InflightMessages
	}
	return nil
}

func (x *SessionState) GetQueuedMessages() []*QueuedMessage {
	if x != nil {
		return x.QueuedMessages
	}
	return nil
}

func (x *SessionState) GetSubscriptions() []*Subscription {
	if x != nil {
		return x.Subscriptions
	}
	return nil
}

func (x *SessionState) GetWill() *WillMessage {
	if x != nil {
		return x.Will
	}
	return nil
}

// InflightMessage represents a message awaiting acknowledgment.
type InflightMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PacketId      uint32                 `protobuf:"varint,1,opt,name=packet_id,json=packetId,proto3" json:"packet_id,omitempty"`
	Topic         string                 `protobuf:"bytes,2,opt,name=topic,proto3" json:"topic,omitempty"`
	Payload       []byte                 `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	Qos           uint32                 `protobuf:"varint,4,opt,name=qos,proto3" json:"qos,omitempty"`
	Retain        bool                   `protobuf:"varint,5,opt,name=retain,proto3" json:"retain,omitempty"`
	Timestamp     int64                  `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InflightMessage) Reset() {
	*x = InflightMessage{}
	mi := &file_broker_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InflightMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InflightMessage) ProtoMessage() {}

func (x *InflightMessage) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InflightMessage.ProtoReflect.Descriptor instead.
func (*InflightMessage) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{4}
}

func (x *InflightMessage) GetPacketId() uint32 {
	if x != nil {
		return x.PacketId
	}
	return 0
}

func (x *InflightMessage) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *InflightMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *InflightMessage) GetQos() uint32 {
	if x != nil {
		return x.Qos
	}
	return 0
}

func (x *InflightMessage) GetRetain() bool {
	if x != nil {
		return x.Retain
	}
	return false
}

func (x *InflightMessage) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// QueuedMessage represents a message in the offline queue.
type QueuedMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Topic         string                 `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Payload       []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	Qos           uint32                 `protobuf:"varint,3,opt,name=qos,proto3" json:"qos,omitempty"`
	Retain        bool                   `protobuf:"varint,4,opt,name=retain,proto3" json:"retain,omitempty"`
	Timestamp     int64                  `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueuedMessage) Reset() {
	*x = QueuedMessage{}
	mi := &file_broker_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueuedMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueuedMessage) ProtoMessage() {}

func (x *QueuedMessage) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueuedMessage.ProtoReflect.Descriptor instead.
func (*QueuedMessage) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{5}
}

func (x *QueuedMessage) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *QueuedMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *QueuedMessage) GetQos() uint32 {
	if x != nil {
		return x.Qos
	}
	return 0
}

func (x *QueuedMessage) GetRetain() bool {
	if x != nil {
		return x.Retain
	}
	return false
}

func (x *QueuedMessage) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// Subscription represents a topic subscription.
type Subscription struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Filter        string                 `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	Qos           uint32                 `protobuf:"varint,2,opt,name=qos,proto3" json:"qos,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Subscription) Reset() {
	*x = Subscription{}
	mi := &file_broker_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Subscription) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Subscription) ProtoMessage() {}

func (x *Subscription) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Subscription.ProtoReflect.Descriptor instead.
func (*Subscription) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{6}
}

func (x *Subscription) GetFilter() string {
	if x != nil {
		return x.Filter
	}
	return ""
}

func (x *Subscription) GetQos() uint32 {
	if x != nil {
		return x.Qos
	}
	return 0
}

// WillMessage represents a last will and testament.
type WillMessage struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Topic          string                 `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Payload        []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	Qos            uint32                 `protobuf:"varint,3,opt,name=qos,proto3" json:"qos,omitempty"`
	Retain         bool                   `protobuf:"varint,4,opt,name=retain,proto3" json:"retain,omitempty"`
	Delay          uint32                 `protobuf:"varint,5,opt,name=delay,proto3" json:"delay,omitempty"`
	DisconnectTime int64                  `protobuf:"varint,6,opt,name=disconnect_time,json=disconnectTime,proto3" json:"disconnect_time,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *WillMessage) Reset() {
	*x = WillMessage{}
	mi := &file_broker_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WillMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WillMessage) ProtoMessage() {}

func (x *WillMessage) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WillMessage.ProtoReflect.Descriptor instead.
func (*WillMessage) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{7}
}

func (x *WillMessage) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *WillMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *WillMessage) GetQos() uint32 {
	if x != nil {
		return x.Qos
	}
	return 0
}

func (x *WillMessage) GetRetain() bool {
	if x != nil {
		return x.Retain
	}
	return false
}

func (x *WillMessage) GetDelay() uint32 {
	if x != nil {
		return x.Delay
	}
	return 0
}

func (x *WillMessage) GetDisconnectTime() int64 {
	if x != nil {
		return x.DisconnectTime
	}
	return 0
}

// TakeoverResponse indicates whether the takeover succeeded and returns session state.
type TakeoverResponse struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Success bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error   string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// Session state transferred from the old node
	SessionState  *SessionState `protobuf:"bytes,3,opt,name=session_state,json=sessionState,proto3" json:"session_state,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TakeoverResponse) Reset() {
	*x = TakeoverResponse{}
	mi := &file_broker_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TakeoverResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TakeoverResponse) ProtoMessage() {}

func (x *TakeoverResponse) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TakeoverResponse.ProtoReflect.Descriptor instead.
func (*TakeoverResponse) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{8}
}

func (x *TakeoverResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *TakeoverResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *TakeoverResponse) GetSessionState() *SessionState {
	if x != nil {
		return x.SessionState
	}
	return nil
}

// FetchRetainedRequest requests a retained message from the owning node.
type FetchRetainedRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Topic         string                 `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"` // Topic of the retained message to fetch
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FetchRetainedRequest) Reset() {
	*x = FetchRetainedRequest{}
	mi := &file_broker_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetchRetainedRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchRetainedRequest) ProtoMessage() {}

func (x *FetchRetainedRequest) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchRetainedRequest.ProtoReflect.Descriptor instead.
func (*FetchRetainedRequest) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{9}
}

func (x *FetchRetainedRequest) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

// RetainedMessage represents a complete retained message with all properties.
type RetainedMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Topic         string                 `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Payload       []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	Qos           uint32                 `protobuf:"varint,3,opt,name=qos,proto3" json:"qos,omitempty"`
	Retain        bool                   `protobuf:"varint,4,opt,name=retain,proto3" json:"retain,omitempty"`
	Properties    map[string]string      `protobuf:"bytes,5,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // MQTT v5 properties
	Timestamp     int64                  `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`                                                                            // When the message was retained
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RetainedMessage) Reset() {
	*x = RetainedMessage{}
	mi := &file_broker_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RetainedMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RetainedMessage) ProtoMessage() {}

func (x *RetainedMessage) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RetainedMessage.ProtoReflect.Descriptor instead.
func (*RetainedMessage) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{10}
}

func (x *RetainedMessage) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *RetainedMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *RetainedMessage) GetQos() uint32 {
	if x != nil {
		return x.Qos
	}
	return 0
}

func (x *RetainedMessage) GetRetain() bool {
	if x != nil {
		return x.Retain
	}
	return false
}

func (x *RetainedMessage) GetProperties() map[string]string {
	if x != nil {
		return x.Properties
	}
	return nil
}

func (x *RetainedMessage) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// FetchRetainedResponse returns the retained message if found.
type FetchRetainedResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Found         bool                   `protobuf:"varint,1,opt,name=found,proto3" json:"found,omitempty"`    // True if message exists
	Message       *RetainedMessage       `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"` // The retained message (only if found=true)
	Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`     // Error message if request failed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FetchRetainedResponse) Reset() {
	*x = FetchRetainedResponse{}
	mi := &file_broker_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetchRetainedResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchRetainedResponse) ProtoMessage() {}

func (x *FetchRetainedResponse) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchRetainedResponse.ProtoReflect.Descriptor instead.
func (*FetchRetainedResponse) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{11}
}

func (x *FetchRetainedResponse) GetFound() bool {
	if x != nil {
		return x.Found
	}
	return false
}

func (x *FetchRetainedResponse) GetMessage() *RetainedMessage {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *FetchRetainedResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// FetchWillRequest requests a will message from the owning node.
type FetchWillRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"` // Client ID whose will message to fetch
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FetchWillRequest) Reset() {
	*x = FetchWillRequest{}
	mi := &file_broker_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetchWillRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchWillRequest) ProtoMessage() {}

func (x *FetchWillRequest) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchWillRequest.ProtoReflect.Descriptor instead.
func (*FetchWillRequest) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{12}
}

func (x *FetchWillRequest) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

// FetchWillResponse returns the will message if found.
type FetchWillResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Found         bool                   `protobuf:"varint,1,opt,name=found,proto3" json:"found,omitempty"`    // True if will message exists
	Message       *WillMessage           `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"` // The will message (only if found=true)
	Error         string                 `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`     // Error message if request failed
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FetchWillResponse) Reset() {
	*x = FetchWillResponse{}
	mi := &file_broker_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetchWillResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchWillResponse) ProtoMessage() {}

func (x *FetchWillResponse) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchWillResponse.ProtoReflect.Descriptor instead.
func (*FetchWillResponse) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{13}
}

func (x *FetchWillResponse) GetFound() bool {
	if x != nil {
		return x.Found
	}
	return false
}

func (x *FetchWillResponse) GetMessage() *WillMessage {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *FetchWillResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// EnqueueRemoteRequest requests enqueueing a message on a remote partition owner.
type EnqueueRemoteRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	QueueName     string                 `protobuf:"bytes,1,opt,name=queue_name,json=queueName,proto3" json:"queue_name,omitempty"`                                                            // Queue topic name
	Payload       []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`                                                                                 // Message payload
	Properties    map[string]string      `protobuf:"bytes,3,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Message properties (including partition-key)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnqueueRemoteRequest) Reset() {
	*x = EnqueueRemoteRequest{}
	mi := &file_broker_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnqueueRemoteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnqueueRemoteRequest) ProtoMessage() {}

func (x *EnqueueRemoteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnqueueRemoteRequest.ProtoReflect.Descriptor instead.
func (*EnqueueRemoteRequest) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{14}
}

func (x *EnqueueRemoteRequest) GetQueueName() string {
	if x != nil {
		return x.QueueName
	}
	return ""
}

func (x *EnqueueRemoteRequest) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *EnqueueRemoteRequest) GetProperties() map[string]string {
	if x != nil {
		return x.Properties
	}
	return nil
}

// EnqueueRemoteResponse indicates whether the enqueue succeeded.
type EnqueueRemoteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`                          // Error message if success=false
	MessageId     string                 `protobuf:"bytes,3,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"` // Generated message ID
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnqueueRemoteResponse) Reset() {
	*x = EnqueueRemoteResponse{}
	mi := &file_broker_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnqueueRemoteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnqueueRemoteResponse) ProtoMessage() {}

func (x *EnqueueRemoteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnqueueRemoteResponse.ProtoReflect.Descriptor instead.
func (*EnqueueRemoteResponse) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{15}
}

func (x *EnqueueRemoteResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *EnqueueRemoteResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *EnqueueRemoteResponse) GetMessageId() string {
	if x != nil {
		return x.MessageId
	}
	return ""
}

// RouteQueueMessageRequest delivers a queue message to a consumer on another node.
type RouteQueueMessageRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`                                                               // Target consumer client ID
	QueueName     string                 `protobuf:"bytes,2,opt,name=queue_name,json=queueName,proto3" json:"queue_name,omitempty"`                                                            // Queue name
	MessageId     string                 `protobuf:"bytes,3,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`                                                            // Message ID
	Payload       []byte                 `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`                                                                                 // Message payload
	Properties    map[string]string      `protobuf:"bytes,5,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"` // Message properties
	Sequence      int64                  `protobuf:"varint,6,opt,name=sequence,proto3" json:"sequence,omitempty"`                                                                              // Message sequence number
	PartitionId   int32                  `protobuf:"varint,7,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`                                                     // Partition ID
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouteQueueMessageRequest) Reset() {
	*x = RouteQueueMessageRequest{}
	mi := &file_broker_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteQueueMessageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteQueueMessageRequest) ProtoMessage() {}

func (x *RouteQueueMessageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteQueueMessageRequest.ProtoReflect.Descriptor instead.
func (*RouteQueueMessageRequest) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{16}
}

func (x *RouteQueueMessageRequest) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *RouteQueueMessageRequest) GetQueueName() string {
	if x != nil {
		return x.QueueName
	}
	return ""
}

func (x *RouteQueueMessageRequest) GetMessageId() string {
	if x != nil {
		return x.MessageId
	}
	return ""
}

func (x *RouteQueueMessageRequest) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *RouteQueueMessageRequest) GetProperties() map[string]string {
	if x != nil {
		return x.Properties
	}
	return nil
}

func (x *RouteQueueMessageRequest) GetSequence() int64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *RouteQueueMessageRequest) GetPartitionId() int32 {
	if x != nil {
		return x.PartitionId
	}
	return 0
}

// RouteQueueMessageResponse indicates whether the delivery succeeded.
type RouteQueueMessageResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"` // Error message if success=false
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouteQueueMessageResponse) Reset() {
	*x = RouteQueueMessageResponse{}
	mi := &file_broker_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteQueueMessageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteQueueMessageResponse) ProtoMessage() {}

func (x *RouteQueueMessageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteQueueMessageResponse.ProtoReflect.Descriptor instead.
func (*RouteQueueMessageResponse) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{17}
}

func (x *RouteQueueMessageResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *RouteQueueMessageResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// AppendEntriesRequest is sent by the leader to replicate log entries.
type AppendEntriesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	QueueName     string                 `protobuf:"bytes,1,opt,name=queue_name,json=queueName,proto3" json:"queue_name,omitempty"`             // Queue name for routing
	PartitionId   int32                  `protobuf:"varint,2,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`      // Partition ID for routing
	Term          uint64                 `protobuf:"varint,3,opt,name=term,proto3" json:"term,omitempty"`                                       // Leader's term
	LeaderId      string                 `protobuf:"bytes,4,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`                // Leader's node ID
	PrevLogIndex  uint64                 `protobuf:"varint,5,opt,name=prev_log_index,json=prevLogIndex,proto3" json:"prev_log_index,omitempty"` // Index of log entry immediately preceding new ones
	PrevLogTerm   uint64                 `protobuf:"varint,6,opt,name=prev_log_term,json=prevLogTerm,proto3" json:"prev_log_term,omitempty"`    // Term of prev_log_index entry
	Entries       [][]byte               `protobuf:"bytes,7,rep,name=entries,proto3" json:"entries,omitempty"`                                  // Log entries to store (serialized)
	LeaderCommit  uint64                 `protobuf:"varint,8,opt,name=leader_commit,json=leaderCommit,proto3" json:"leader_commit,omitempty"`   // Leader's commit index
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppendEntriesRequest) Reset() {
	*x = AppendEntriesRequest{}
	mi := &file_broker_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppendEntriesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppendEntriesRequest) ProtoMessage() {}

func (x *AppendEntriesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppendEntriesRequest.ProtoReflect.Descriptor instead.
func (*AppendEntriesRequest) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{18}
}

func (x *AppendEntriesRequest) GetQueueName() string {
	if x != nil {
		return x.QueueName
	}
	return ""
}

func (x *AppendEntriesRequest) GetPartitionId() int32 {
	if x != nil {
		return x.PartitionId
	}
	return 0
}

func (x *AppendEntriesRequest) GetTerm() uint64 {
	if x != nil {
		return x.Term
	}
	return 0
}

func (x *AppendEntriesRequest) GetLeaderId() string {
	if x != nil {
		return x.LeaderId
	}
	return ""
}

func (x *AppendEntriesRequest) GetPrevLogIndex() uint64 {
	if x != nil {
		return x.PrevLogIndex
	}
	return 0
}

func (x *AppendEntriesRequest) GetPrevLogTerm() uint64 {
	if x != nil {
		return x.PrevLogTerm
	}
	return 0
}

func (x *AppendEntriesRequest) GetEntries() [][]byte {
	if x != nil {
		return x.Entries
	}
	return nil
}

func (x *AppendEntriesRequest) GetLeaderCommit() uint64 {
	if x != nil {
		return x.LeaderCommit
	}
	return 0
}

// AppendEntriesResponse is the response to AppendEntries.
type AppendEntriesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Term          uint64                 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`                                       // Current term, for leader to update itself
	Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`                                 // True if follower contained entry matching prev_log_index and prev_log_term
	LastLogIndex  uint64                 `protobuf:"varint,3,opt,name=last_log_index,json=lastLogIndex,proto3" json:"last_log_index,omitempty"` // Follower's last log index (for leader to update next_index)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppendEntriesResponse) Reset() {
	*x = AppendEntriesResponse{}
	mi := &file_broker_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppendEntriesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppendEntriesResponse) ProtoMessage() {}

func (x *AppendEntriesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppendEntriesResponse.ProtoReflect.Descriptor instead.
func (*AppendEntriesResponse) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{19}
}

func (x *AppendEntriesResponse) GetTerm() uint64 {
	if x != nil {
		return x.Term
	}
	return 0
}

func (x *AppendEntriesResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *AppendEntriesResponse) GetLastLogIndex() uint64 {
	if x != nil {
		return x.LastLogIndex
	}
	return 0
}

// RequestVoteRequest is sent by candidates during leader election.
type RequestVoteRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	QueueName     string                 `protobuf:"bytes,1,opt,name=queue_name,json=queueName,proto3" json:"queue_name,omitempty"`             // Queue name for routing
	PartitionId   int32                  `protobuf:"varint,2,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`      // Partition ID for routing
	Term          uint64                 `protobuf:"varint,3,opt,name=term,proto3" json:"term,omitempty"`                                       // Candidate's term
	CandidateId   string                 `protobuf:"bytes,4,opt,name=candidate_id,json=candidateId,proto3" json:"candidate_id,omitempty"`       // Candidate's node ID
	LastLogIndex  uint64                 `protobuf:"varint,5,opt,name=last_log_index,json=lastLogIndex,proto3" json:"last_log_index,omitempty"` // Index of candidate's last log entry
	LastLogTerm   uint64                 `protobuf:"varint,6,opt,name=last_log_term,json=lastLogTerm,proto3" json:"last_log_term,omitempty"`    // Term of candidate's last log entry
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RequestVoteRequest) Reset() {
	*x = RequestVoteRequest{}
	mi := &file_broker_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestVoteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestVoteRequest) ProtoMessage() {}

func (x *RequestVoteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestVoteRequest.ProtoReflect.Descriptor instead.
func (*RequestVoteRequest) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{20}
}

func (x *RequestVoteRequest) GetQueueName() string {
	if x != nil {
		return x.QueueName
	}
	return ""
}

func (x *RequestVoteRequest) GetPartitionId() int32 {
	if x != nil {
		return x.PartitionId
	}
	return 0
}

func (x *RequestVoteRequest) GetTerm() uint64 {
	if x != nil {
		return x.Term
	}
	return 0
}

func (x *RequestVoteRequest) GetCandidateId() string {
	if x != nil {
		return x.CandidateId
	}
	return ""
}

func (x *RequestVoteRequest) GetLastLogIndex() uint64 {
	if x != nil {
		return x.LastLogIndex
	}
	return 0
}

func (x *RequestVoteRequest) GetLastLogTerm() uint64 {
	if x != nil {
		return x.LastLogTerm
	}
	return 0
}

// RequestVoteResponse is the response to RequestVote.
type RequestVoteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Term          uint64                 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`                                  // Current term, for candidate to update itself
	VoteGranted   bool                   `protobuf:"varint,2,opt,name=vote_granted,json=voteGranted,proto3" json:"vote_granted,omitempty"` // True if candidate received vote
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RequestVoteResponse) Reset() {
	*x = RequestVoteResponse{}
	mi := &file_broker_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestVoteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestVoteResponse) ProtoMessage() {}

func (x *RequestVoteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestVoteResponse.ProtoReflect.Descriptor instead.
func (*RequestVoteResponse) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{21}
}

func (x *RequestVoteResponse) GetTerm() uint64 {
	if x != nil {
		return x.Term
	}
	return 0
}

func (x *RequestVoteResponse) GetVoteGranted() bool {
	if x != nil {
		return x.VoteGranted
	}
	return false
}

// InstallSnapshotRequest is sent by leader to transfer snapshot to follower.
type InstallSnapshotRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	QueueName         string                 `protobuf:"bytes,1,opt,name=queue_name,json=queueName,proto3" json:"queue_name,omitempty"`                            // Queue name for routing
	PartitionId       int32                  `protobuf:"varint,2,opt,name=partition_id,json=partitionId,proto3" json:"partition_id,omitempty"`                     // Partition ID for routing
	Term              uint64                 `protobuf:"varint,3,opt,name=term,proto3" json:"term,omitempty"`                                                      // Leader's term
	LeaderId          string                 `protobuf:"bytes,4,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`                               // Leader's node ID
	LastIncludedIndex uint64                 `protobuf:"varint,5,opt,name=last_included_index,json=lastIncludedIndex,proto3" json:"last_included_index,omitempty"` // Snapshot replaces all entries up through this index
	LastIncludedTerm  uint64                 `protobuf:"varint,6,opt,name=last_included_term,json=lastIncludedTerm,proto3" json:"last_included_term,omitempty"`    // Term of last_included_index
	Data              []byte                 `protobuf:"bytes,7,opt,name=data,proto3" json:"data,omitempty"`                                                       // Snapshot data (chunk)
	Done              bool                   `protobuf:"varint,8,opt,name=done,proto3" json:"done,omitempty"`                                                      // True if this is the last chunk
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *InstallSnapshotRequest) Reset() {
	*x = InstallSnapshotRequest{}
	mi := &file_broker_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstallSnapshotRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstallSnapshotRequest) ProtoMessage() {}

func (x *InstallSnapshotRequest) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstallSnapshotRequest.ProtoReflect.Descriptor instead.
func (*InstallSnapshotRequest) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{22}
}

func (x *InstallSnapshotRequest) GetQueueName() string {
	if x != nil {
		return x.QueueName
	}
	return ""
}

func (x *InstallSnapshotRequest) GetPartitionId() int32 {
	if x != nil {
		return x.PartitionId
	}
	return 0
}

func (x *InstallSnapshotRequest) GetTerm() uint64 {
	if x != nil {
		return x.Term
	}
	return 0
}

func (x *InstallSnapshotRequest) GetLeaderId() string {
	if x != nil {
		return x.LeaderId
	}
	return ""
}

func (x *InstallSnapshotRequest) GetLastIncludedIndex() uint64 {
	if x != nil {
		return x.LastIncludedIndex
	}
	return 0
}

func (x *InstallSnapshotRequest) GetLastIncludedTerm() uint64 {
	if x != nil {
		return x.LastIncludedTerm
	}
	return 0
}

func (x *InstallSnapshotRequest) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *InstallSnapshotRequest) GetDone() bool {
	if x != nil {
		return x.Done
	}
	return false
}

// InstallSnapshotResponse is the response to InstallSnapshot.
type InstallSnapshotResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Term          uint64                 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"` // Current term, for leader to update itself
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstallSnapshotResponse) Reset() {
	*x = InstallSnapshotResponse{}
	mi := &file_broker_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstallSnapshotResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstallSnapshotResponse) ProtoMessage() {}

func (x *InstallSnapshotResponse) ProtoReflect() protoreflect.Message {
	mi := &file_broker_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstallSnapshotResponse.ProtoReflect.Descriptor instead.
func (*InstallSnapshotResponse) Descriptor() ([]byte, []int) {
	return file_broker_proto_rawDescGZIP(), []int{23}
}

func (x *InstallSnapshotResponse) GetTerm() uint64 {
	if x != nil {
		return x.Term
	}
	return 0
}

var File_broker_proto protoreflect.FileDescriptor

const file_broker_proto_rawDesc = "" +
	"\n" +
	"\fbroker.proto\x12\acluster\"\xa1\x02\n" +
	"\x0ePublishRequest\x12\x1b\n" +
	"\tclient_id\x18\x01 \x01(\tR\bclientId\x12\x14\n" +
	"\x05topic\x18\x02 \x01(\tR\x05topic\x12\x18\n" +
	"\apayload\x18\x03 \x01(\fR\apayload\x12\x10\n" +
	"\x03qos\x18\x04 \x01(\rR\x03qos\x12\x16\n" +
	"\x06retain\x18\x05 \x01(\bR\x06retain\x12\x10\n" +
	"\x03dup\x18\x06 \x01(\bR\x03dup\x12G\n" +
	"\n" +
	"properties\x18\a \x03(\v2'.cluster.PublishRequest.PropertiesEntryR\n" +
	"properties\x1a=\n" +
	"\x0fPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"A\n" +
	"\x0fPublishResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"d\n" +
	"\x0fTakeoverRequest\x12\x1b\n" +
	"\tclient_id\x18\x01 \x01(\tR\bclientId\x12\x1b\n" +
	"\tfrom_node\x18\x02 \x01(\tR\bfromNode\x12\x17\n" +
	"\ato_node\x18\x03 \x01(\tR\x06toNode\"\xc7\x02\n" +
	"\fSessionState\x12'\n" +
	"\x0fexpiry_interval\x18\x01 \x01(\rR\x0eexpiryInterval\x12\x1f\n" +
	"\vclean_start\x18\x02 \x01(\bR\n" +
	"cleanStart\x12E\n" +
	"\x11inflight_messages\x18\x03 \x03(\v2\x18.cluster.InflightMessageR\x10inflightMessages\x12?\n" +
	"\x0fqueued_messages\x18\x04 \x03(\v2\x16.cluster.QueuedMessageR\x0equeuedMessages\x12;\n" +
	"\rsubscriptions\x18\x05 \x03(\v2\x15.cluster.SubscriptionR\rsubscriptions\x12(\n" +
	"\x04will\x18\x06 \x01(\v2\x14.cluster.WillMessageR\x04will\"\xa6\x01\n" +
	"\x0fInflightMessage\x12\x1b\n" +
	"\tpacket_id\x18\x01 \x01(\rR\bpacketId\x12\x14\n" +
	"\x05topic\x18\x02 \x01(\tR\x05topic\x12\x18\n" +
	"\apayload\x18\x03 \x01(\fR\apayload\x12\x10\n" +
	"\x03qos\x18\x04 \x01(\rR\x03qos\x12\x16\n" +
	"\x06retain\x18\x05 \x01(\bR\x06retain\x12\x1c\n" +
	"\ttimestamp\x18\x06 \x01(\x03R\ttimestamp\"\x87\x01\n" +
	"\rQueuedMessage\x12\x14\n" +
	"\x05topic\x18\x01 \x01(\tR\x05topic\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayload\x12\x10\n" +
	"\x03qos\x18\x03 \x01(\rR\x03qos\x12\x16\n" +
	"\x06retain\x18\x04 \x01(\bR\x06retain\x12\x1c\n" +
	"\ttimestamp\x18\x05 \x01(\x03R\ttimestamp\"8\n" +
	"\fSubscription\x12\x16\n" +
	"\x06filter\x18\x01 \x01(\tR\x06filter\x12\x10\n" +
	"\x03qos\x18\x02 \x01(\rR\x03qos\"\xa6\x01\n" +
	"\vWillMessage\x12\x14\n" +
	"\x05topic\x18\x01 \x01(\tR\x05topic\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayload\x12\x10\n" +
	"\x03qos\x18\x03 \x01(\rR\x03qos\x12\x16\n" +
	"\x06retain\x18\x04 \x01(\bR\x06retain\x12\x14\n" +
	"\x05delay\x18\x05 \x01(\rR\x05delay\x12'\n" +
	"\x0fdisconnect_time\x18\x06 \x01(\x03R\x0edisconnectTime\"~\n" +
	"\x10TakeoverResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12:\n" +
	"\rsession_state\x18\x03 \x01(\v2\x15.cluster.SessionStateR\fsessionState\",\n" +
	"\x14FetchRetainedRequest\x12\x14\n" +
	"\x05topic\x18\x01 \x01(\tR\x05topic\"\x92\x02\n" +
	"\x0fRetainedMessage\x12\x14\n" +
	"\x05topic\x18\x01 \x01(\tR\x05topic\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayload\x12\x10\n" +
	"\x03qos\x18\x03 \x01(\rR\x03qos\x12\x16\n" +
	"\x06retain\x18\x04 \x01(\bR\x06retain\x12H\n" +
	"\n" +
	"properties\x18\x05 \x03(\v2(.cluster.RetainedMessage.PropertiesEntryR\n" +
	"properties\x12\x1c\n" +
	"\ttimestamp\x18\x06 \x01(\x03R\ttimestamp\x1a=\n" +
	"\x0fPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"w\n" +
	"\x15FetchRetainedResponse\x12\x14\n" +
	"\x05found\x18\x01 \x01(\bR\x05found\x122\n" +
	"\amessage\x18\x02 \x01(\v2\x18.cluster.RetainedMessageR\amessage\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"/\n" +
	"\x10FetchWillRequest\x12\x1b\n" +
	"\tclient_id\x18\x01 \x01(\tR\bclientId\"o\n" +
	"\x11FetchWillResponse\x12\x14\n" +
	"\x05found\x18\x01 \x01(\bR\x05found\x12.\n" +
	"\amessage\x18\x02 \x01(\v2\x14.cluster.WillMessageR\amessage\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"\xdd\x01\n" +
	"\x14EnqueueRemoteRequest\x12\x1d\n" +
	"\n" +
	"queue_name\x18\x01 \x01(\tR\tqueueName\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayload\x12M\n" +
	"\n" +
	"properties\x18\x03 \x03(\v2-.cluster.EnqueueRemoteRequest.PropertiesEntryR\n" +
	"properties\x1a=\n" +
	"\x0fPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"f\n" +
	"\x15EnqueueRemoteResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12\x1d\n" +
	"\n" +
	"message_id\x18\x03 \x01(\tR\tmessageId\"\xe0\x02\n" +
	"\x18RouteQueueMessageRequest\x12\x1b\n" +
	"\tclient_id\x18\x01 \x01(\tR\bclientId\x12\x1d\n" +
	"\n" +
	"queue_name\x18\x02 \x01(\tR\tqueueName\x12\x1d\n" +
	"\n" +
	"message_id\x18\x03 \x01(\tR\tmessageId\x12\x18\n" +
	"\apayload\x18\x04 \x01(\fR\apayload\x12Q\n" +
	"\n" +
	"properties\x18\x05 \x03(\v21.cluster.RouteQueueMessageRequest.PropertiesEntryR\n" +
	"properties\x12\x1a\n" +
	"\bsequence\x18\x06 \x01(\x03R\bsequence\x12!\n" +
	"\fpartition_id\x18\a \x01(\x05R\vpartitionId\x1a=\n" +
	"\x0fPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"K\n" +
	"\x19RouteQueueMessageResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\x92\x02\n" +
	"\x14AppendEntriesRequest\x12\x1d\n" +
	"\n" +
	"queue_name\x18\x01 \x01(\tR\tqueueName\x12!\n" +
	"\fpartition_id\x18\x02 \x01(\x05R\vpartitionId\x12\x12\n" +
	"\x04term\x18\x03 \x01(\x04R\x04term\x12\x1b\n" +
	"\tleader_id\x18\x04 \x01(\tR\bleaderId\x12$\n" +
	"\x0eprev_log_index\x18\x05 \x01(\x04R\fprevLogIndex\x12\"\n" +
	"\rprev_log_term\x18\x06 \x01(\x04R\vprevLogTerm\x12\x18\n" +
	"\aentries\x18\a \x03(\fR\aentries\x12#\n" +
	"\rleader_commit\x18\b \x01(\x04R\fleaderCommit\"k\n" +
	"\x15AppendEntriesResponse\x12\x12\n" +
	"\x04term\x18\x01 \x01(\x04R\x04term\x12\x18\n" +
	"\asuccess\x18\x02 \x01(\bR\asuccess\x12$\n" +
	"\x0elast_log_index\x18\x03 \x01(\x04R\flastLogIndex\"\xd7\x01\n" +
	"\x12RequestVoteRequest\x12\x1d\n" +
	"\n" +
	"queue_name\x18\x01 \x01(\tR\tqueueName\x12!\n" +
	"\fpartition_id\x18\x02 \x01(\x05R\vpartitionId\x12\x12\n" +
	"\x04term\x18\x03 \x01(\x04R\x04term\x12!\n" +
	"\fcandidate_id\x18\x04 \x01(\tR\vcandidateId\x12$\n" +
	"\x0elast_log_index\x18\x05 \x01(\x04R\flastLogIndex\x12\"\n" +
	"\rlast_log_term\x18\x06 \x01(\x04R\vlastLogTerm\"L\n" +
	"\x13RequestVoteResponse\x12\x12\n" +
	"\x04term\x18\x01 \x01(\x04R\x04term\x12!\n" +
	"\fvote_granted\x18\x02 \x01(\bR\vvoteGranted\"\x91\x02\n" +
	"\x16InstallSnapshotRequest\x12\x1d\n" +
	"\n" +
	"queue_name\x18\x01 \x01(\tR\tqueueName\x12!\n" +
	"\fpartition_id\x18\x02 \x01(\x05R\vpartitionId\x12\x12\n" +
	"\x04term\x18\x03 \x01(\x04R\x04term\x12\x1b\n" +
	"\tleader_id\x18\x04 \x01(\tR\bleaderId\x12.\n" +
	"\x13last_included_index\x18\x05 \x01(\x04R\x11lastIncludedIndex\x12,\n" +
	"\x12last_included_term\x18\x06 \x01(\x04R\x10lastIncludedTerm\x12\x12\n" +
	"\x04data\x18\a \x01(\fR\x04data\x12\x12\n" +
	"\x04done\x18\b \x01(\bR\x04done\"-\n" +
	"\x17InstallSnapshotResponse\x12\x12\n" +
	"\x04term\x18\x01 \x01(\x04R\x04term2\xca\x05\n" +
	"\rBrokerService\x12A\n" +
	"\fRoutePublish\x12\x17.cluster.PublishRequest\x1a\x18.cluster.PublishResponse\x12F\n" +
	"\x0fTakeoverSession\x12\x18.cluster.TakeoverRequest\x1a\x19.cluster.TakeoverResponse\x12N\n" +
	"\rFetchRetained\x12\x1d.cluster.FetchRetainedRequest\x1a\x1e.cluster.FetchRetainedResponse\x12B\n" +
	"\tFetchWill\x12\x19.cluster.FetchWillRequest\x1a\x1a.cluster.FetchWillResponse\x12N\n" +
	"\rEnqueueRemote\x12\x1d.cluster.EnqueueRemoteRequest\x1a\x1e.cluster.EnqueueRemoteResponse\x12Z\n" +
	"\x11RouteQueueMessage\x12!.cluster.RouteQueueMessageRequest\x1a\".cluster.RouteQueueMessageResponse\x12N\n" +
	"\rAppendEntries\x12\x1d.cluster.AppendEntriesRequest\x1a\x1e.cluster.AppendEntriesResponse\x12H\n" +
	"\vRequestVote\x12\x1b.cluster.RequestVoteRequest\x1a\x1c.cluster.RequestVoteResponse\x12T\n" +
	"\x0fInstallSnapshot\x12\x1f.cluster.InstallSnapshotRequest\x1a .cluster.InstallSnapshotResponseB&Z$github.com/absmach/fluxmq/cluster/grpcb\x06proto3"

var (
	file_broker_proto_rawDescOnce sync.Once
	file_broker_proto_rawDescData []byte
)

func file_broker_proto_rawDescGZIP() []byte {
	file_broker_proto_rawDescOnce.Do(func() {
		file_broker_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_broker_proto_rawDesc), len(file_broker_proto_rawDesc)))
	})
	return file_broker_proto_rawDescData
}

var (
	file_broker_proto_msgTypes = make([]protoimpl.MessageInfo, 28)
	file_broker_proto_goTypes  = []any{
		(*PublishRequest)(nil),            // 0: cluster.PublishRequest
		(*PublishResponse)(nil),           // 1: cluster.PublishResponse
		(*TakeoverRequest)(nil),           // 2: cluster.TakeoverRequest
		(*SessionState)(nil),              // 3: cluster.SessionState
		(*InflightMessage)(nil),           // 4: cluster.InflightMessage
		(*QueuedMessage)(nil),             // 5: cluster.QueuedMessage
		(*Subscription)(nil),              // 6: cluster.Subscription
		(*WillMessage)(nil),               // 7: cluster.WillMessage
		(*TakeoverResponse)(nil),          // 8: cluster.TakeoverResponse
		(*FetchRetainedRequest)(nil),      // 9: cluster.FetchRetainedRequest
		(*RetainedMessage)(nil),           // 10: cluster.RetainedMessage
		(*FetchRetainedResponse)(nil),     // 11: cluster.FetchRetainedResponse
		(*FetchWillRequest)(nil),          // 12: cluster.FetchWillRequest
		(*FetchWillResponse)(nil),         // 13: cluster.FetchWillResponse
		(*EnqueueRemoteRequest)(nil),      // 14: cluster.EnqueueRemoteRequest
		(*EnqueueRemoteResponse)(nil),     // 15: cluster.EnqueueRemoteResponse
		(*RouteQueueMessageRequest)(nil),  // 16: cluster.RouteQueueMessageRequest
		(*RouteQueueMessageResponse)(nil), // 17: cluster.RouteQueueMessageResponse
		(*AppendEntriesRequest)(nil),      // 18: cluster.AppendEntriesRequest
		(*AppendEntriesResponse)(nil),     // 19: cluster.AppendEntriesResponse
		(*RequestVoteRequest)(nil),        // 20: cluster.RequestVoteRequest
		(*RequestVoteResponse)(nil),       // 21: cluster.RequestVoteResponse
		(*InstallSnapshotRequest)(nil),    // 22: cluster.InstallSnapshotRequest
		(*InstallSnapshotResponse)(nil),   // 23: cluster.InstallSnapshotResponse
		nil,                               // 24: cluster.PublishRequest.PropertiesEntry
		nil,                               // 25: cluster.RetainedMessage.PropertiesEntry
		nil,                               // 26: cluster.EnqueueRemoteRequest.PropertiesEntry
		nil,                               // 27: cluster.RouteQueueMessageRequest.PropertiesEntry
	}
)
var file_broker_proto_depIdxs = []int32{
	24, // 0: cluster.PublishRequest.properties:type_name -> cluster.PublishRequest.PropertiesEntry
	4,  // 1: cluster.SessionState.inflight_messages:type_name -> cluster.InflightMessage
	5,  // 2: cluster.SessionState.queued_messages:type_name -> cluster.QueuedMessage
	6,  // 3: cluster.SessionState.subscriptions:type_name -> cluster.Subscription
	7,  // 4: cluster.SessionState.will:type_name -> cluster.WillMessage
	3,  // 5: cluster.TakeoverResponse.session_state:type_name -> cluster.SessionState
	25, // 6: cluster.RetainedMessage.properties:type_name -> cluster.RetainedMessage.PropertiesEntry
	10, // 7: cluster.FetchRetainedResponse.message:type_name -> cluster.RetainedMessage
	7,  // 8: cluster.FetchWillResponse.message:type_name -> cluster.WillMessage
	26, // 9: cluster.EnqueueRemoteRequest.properties:type_name -> cluster.EnqueueRemoteRequest.PropertiesEntry
	27, // 10: cluster.RouteQueueMessageRequest.properties:type_name -> cluster.RouteQueueMessageRequest.PropertiesEntry
	0,  // 11: cluster.BrokerService.RoutePublish:input_type -> cluster.PublishRequest
	2,  // 12: cluster.BrokerService.TakeoverSession:input_type -> cluster.TakeoverRequest
	9,  // 13: cluster.BrokerService.FetchRetained:input_type -> cluster.FetchRetainedRequest
	12, // 14: cluster.BrokerService.FetchWill:input_type -> cluster.FetchWillRequest
	14, // 15: cluster.BrokerService.EnqueueRemote:input_type -> cluster.EnqueueRemoteRequest
	16, // 16: cluster.BrokerService.RouteQueueMessage:input_type -> cluster.RouteQueueMessageRequest
	18, // 17: cluster.BrokerService.AppendEntries:input_type -> cluster.AppendEntriesRequest
	20, // 18: cluster.BrokerService.RequestVote:input_type -> cluster.RequestVoteRequest
	22, // 19: cluster.BrokerService.InstallSnapshot:input_type -> cluster.InstallSnapshotRequest
	1,  // 20: cluster.BrokerService.RoutePublish:output_type -> cluster.PublishResponse
	8,  // 21: cluster.BrokerService.TakeoverSession:output_type -> cluster.TakeoverResponse
	11, // 22: cluster.BrokerService.FetchRetained:output_type -> cluster.FetchRetainedResponse
	13, // 23: cluster.BrokerService.FetchWill:output_type -> cluster.FetchWillResponse
	15, // 24: cluster.BrokerService.EnqueueRemote:output_type -> cluster.EnqueueRemoteResponse
	17, // 25: cluster.BrokerService.RouteQueueMessage:output_type -> cluster.RouteQueueMessageResponse
	19, // 26: cluster.BrokerService.AppendEntries:output_type -> cluster.AppendEntriesResponse
	21, // 27: cluster.BrokerService.RequestVote:output_type -> cluster.RequestVoteResponse
	23, // 28: cluster.BrokerService.InstallSnapshot:output_type -> cluster.InstallSnapshotResponse
	20, // [20:29] is the sub-list for method output_type
	11, // [11:20] is the sub-list for method input_type
	11, // [11:11] is the sub-list for extension type_name
	11, // [11:11] is the sub-list for extension extendee
	0,  // [0:11] is the sub-list for field type_name
}

func init() { file_broker_proto_init() }
func file_broker_proto_init() {
	if File_broker_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_broker_proto_rawDesc), len(file_broker_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   28,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_broker_proto_goTypes,
		DependencyIndexes: file_broker_proto_depIdxs,
		MessageInfos:      file_broker_proto_msgTypes,
	}.Build()
	File_broker_proto = out.File
	file_broker_proto_goTypes = nil
	file_broker_proto_depIdxs = nil
}
