# Absmach MQTT Broker Configuration Example

# Server Configuration
server:
  # TCP listeners (MQTT over TCP)
  tcp:
    plain:
      addr: ":1883"
      max_connections: 10000
      read_timeout: 60s
      write_timeout: 60s
    tls: {}
    mtls: {}

  # WebSocket listeners (MQTT over WebSocket)
  websocket:
    plain:
      addr: ":8083"
      path: "/mqtt"
    tls: {}
    mtls: {}

  # HTTP-MQTT bridge listeners
  http:
    plain: {}
    tls: {}
    mtls: {}

  # CoAP bridge listeners
  coap:
    plain: {}
    dtls: {}
    mdtls: {}

  # Health Check Server
  health_enabled: true
  health_addr: ":8081"

  # Graceful shutdown timeout
  shutdown_timeout: 30s

# Broker Configuration
broker:
  # Maximum message size in bytes
  max_message_size: 1048576  # 1MB

  # Maximum retained messages
  max_retained_messages: 10000

  # QoS retry settings
  retry_interval: 20s
  max_retries: 0  # 0 = infinite retries

# Session Configuration
session:
  # Maximum concurrent sessions
  max_sessions: 10000

  # Default session expiry (seconds) if client doesn't specify
  default_expiry_interval: 300  # 5 minutes

  # Maximum queued messages per offline client
  max_offline_queue_size: 1000

  # Maximum inflight messages per session (QoS 1/2)
  max_inflight_messages: 100

# Logging Configuration
log:
  level: "info"   # debug, info, warn, error
  format: "text"  # text, json

# Storage Configuration
storage:
  type: "badger"  # memory, badger

  # BadgerDB settings (only if type=badger)
  badger_dir: "/tmp/mqtt/data"

# Cluster Configuration
cluster:
  enabled: false
  node_id: "broker-1"

  # Embedded etcd configuration
  etcd:
    data_dir: "/tmp/mqtt/etcd"
    bind_addr: "0.0.0.0:2380"
    client_addr: "0.0.0.0:2379"
    initial_cluster: "broker-1=http://0.0.0.0:2380"
    bootstrap: true

  # Inter-broker transport
  transport:
    bind_addr: "0.0.0.0:7948"
    peers: {}  # Map of nodeID -> address for other nodes

# Webhook Configuration
webhook:
  # Enable/disable webhooks
  enabled: false

  # Event queue settings
  queue_size: 10000
  drop_policy: "oldest"  # "oldest" or "newest" when queue is full
  workers: 5            # Number of concurrent webhook workers

  # Include message payload in webhook events (base64 encoded)
  include_payload: false

  # Graceful shutdown timeout for draining queue
  shutdown_timeout: 30s

  # Default settings for all endpoints
  defaults:
    timeout: 5s

    retry:
      max_attempts: 3
      initial_interval: 1s
      max_interval: 30s
      multiplier: 2.0

    circuit_breaker:
      failure_threshold: 5
      reset_timeout: 60s

  # Webhook endpoints
  endpoints:
    # Example: Analytics service
    - name: "analytics-service"
      type: "http"
      url: "https://analytics.example.com/mqtt/events"

      # Filter by event type (empty = all events)
      events:
        - "message.published"
        - "client.connected"
        - "client.disconnected"

      # Filter by topic pattern for message events (empty = all topics)
      topic_filters:
        - "sensors/#"
        - "devices/+/telemetry"

      # Custom headers (e.g., authentication)
      headers:
        Authorization: "Bearer your-secret-token"
        X-Service-Name: "mqtt-broker"

      # Override default settings (optional)
      timeout: 10s
      retry:
        max_attempts: 5

    # Example: Audit system for security events
    - name: "audit-system"
      type: "http"
      url: "https://audit.example.com/events"

      # Only security-related events
      events:
        - "auth.failure"
        - "authz.publish_denied"
        - "authz.subscribe_denied"

      headers:
        Authorization: "Bearer audit-token"

# Queue Configuration
# Queues are used for durable, persistent message delivery.
# Messages published to topics starting with $queue/ are routed to matching queues.
queues:
  # Default MQTT queue - captures all $queue/* messages
  - name: "mqtt"
    topics:
      - "$queue/#"
    reserved: true
    limits:
      max_message_size: 10485760  # 10MB
      max_depth: 100000
      message_ttl: 168h  # 7 days
    retry:
      max_retries: 10
      initial_backoff: 5s
      max_backoff: 5m
      multiplier: 2.0
    dlq:
      enabled: true

# Queue Usage:
#   Publish: Client publishes to "$queue/mqtt/orders/created"
#   Subscribe: Client subscribes to "$queue/mqtt/orders/#" with consumer-group property
#   Messages are delivered with at-least-once semantics
#   Acknowledge: Client publishes to "$queue/mqtt/orders/created/$ack" with message-id property

# Event Types Reference:
# - client.connected          : Client successfully connected
# - client.disconnected       : Client disconnected
# - client.session_takeover   : Session migrated between cluster nodes
# - message.published         : Message published to broker
# - message.delivered         : Message delivered to subscriber
# - message.retained          : Retained message set or cleared
# - subscription.created      : Client subscribed to topic
# - subscription.removed      : Client unsubscribed from topic
# - auth.success              : Authentication succeeded
# - auth.failure              : Authentication failed
# - authz.publish_denied      : Publish authorization denied
# - authz.subscribe_denied    : Subscribe authorization denied
