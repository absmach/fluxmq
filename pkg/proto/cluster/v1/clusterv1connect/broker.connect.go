// Copyright (c) Abstract Machines
// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: cluster/v1/broker.proto

package clusterv1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/absmach/fluxmq/pkg/proto/cluster/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// BrokerServiceName is the fully-qualified name of the BrokerService service.
	BrokerServiceName = "fluxmq.cluster.v1.BrokerService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// BrokerServiceRoutePublishProcedure is the fully-qualified name of the BrokerService's
	// RoutePublish RPC.
	BrokerServiceRoutePublishProcedure = "/fluxmq.cluster.v1.BrokerService/RoutePublish"
	// BrokerServiceRoutePublishBatchProcedure is the fully-qualified name of the BrokerService's
	// RoutePublishBatch RPC.
	BrokerServiceRoutePublishBatchProcedure = "/fluxmq.cluster.v1.BrokerService/RoutePublishBatch"
	// BrokerServiceTakeoverSessionProcedure is the fully-qualified name of the BrokerService's
	// TakeoverSession RPC.
	BrokerServiceTakeoverSessionProcedure = "/fluxmq.cluster.v1.BrokerService/TakeoverSession"
	// BrokerServiceFetchRetainedProcedure is the fully-qualified name of the BrokerService's
	// FetchRetained RPC.
	BrokerServiceFetchRetainedProcedure = "/fluxmq.cluster.v1.BrokerService/FetchRetained"
	// BrokerServiceFetchWillProcedure is the fully-qualified name of the BrokerService's FetchWill RPC.
	BrokerServiceFetchWillProcedure = "/fluxmq.cluster.v1.BrokerService/FetchWill"
	// BrokerServiceEnqueueRemoteProcedure is the fully-qualified name of the BrokerService's
	// EnqueueRemote RPC.
	BrokerServiceEnqueueRemoteProcedure = "/fluxmq.cluster.v1.BrokerService/EnqueueRemote"
	// BrokerServiceRouteQueueMessageProcedure is the fully-qualified name of the BrokerService's
	// RouteQueueMessage RPC.
	BrokerServiceRouteQueueMessageProcedure = "/fluxmq.cluster.v1.BrokerService/RouteQueueMessage"
	// BrokerServiceRouteQueueBatchProcedure is the fully-qualified name of the BrokerService's
	// RouteQueueBatch RPC.
	BrokerServiceRouteQueueBatchProcedure = "/fluxmq.cluster.v1.BrokerService/RouteQueueBatch"
	// BrokerServiceAppendEntriesProcedure is the fully-qualified name of the BrokerService's
	// AppendEntries RPC.
	BrokerServiceAppendEntriesProcedure = "/fluxmq.cluster.v1.BrokerService/AppendEntries"
	// BrokerServiceRequestVoteProcedure is the fully-qualified name of the BrokerService's RequestVote
	// RPC.
	BrokerServiceRequestVoteProcedure = "/fluxmq.cluster.v1.BrokerService/RequestVote"
	// BrokerServiceInstallSnapshotProcedure is the fully-qualified name of the BrokerService's
	// InstallSnapshot RPC.
	BrokerServiceInstallSnapshotProcedure = "/fluxmq.cluster.v1.BrokerService/InstallSnapshot"
	// BrokerServiceForwardGroupOpProcedure is the fully-qualified name of the BrokerService's
	// ForwardGroupOp RPC.
	BrokerServiceForwardGroupOpProcedure = "/fluxmq.cluster.v1.BrokerService/ForwardGroupOp"
)

// BrokerServiceClient is a client for the fluxmq.cluster.v1.BrokerService service.
type BrokerServiceClient interface {
	// RoutePublish forwards a PUBLISH packet to the broker that owns the target session.
	RoutePublish(context.Context, *connect.Request[v1.PublishRequest]) (*connect.Response[v1.PublishResponse], error)
	// RoutePublishBatch forwards multiple PUBLISH packets in one RPC.
	RoutePublishBatch(context.Context, *connect.Request[v1.PublishBatchRequest]) (*connect.Response[v1.PublishBatchResponse], error)
	// TakeoverSession migrates a session from one broker to another.
	TakeoverSession(context.Context, *connect.Request[v1.TakeoverRequest]) (*connect.Response[v1.TakeoverResponse], error)
	// FetchRetained fetches a retained message payload from the owning broker node.
	FetchRetained(context.Context, *connect.Request[v1.FetchRetainedRequest]) (*connect.Response[v1.FetchRetainedResponse], error)
	// FetchWill fetches a will message payload from the owning broker node.
	FetchWill(context.Context, *connect.Request[v1.FetchWillRequest]) (*connect.Response[v1.FetchWillResponse], error)
	// EnqueueRemote routes an enqueue operation to the remote node.
	EnqueueRemote(context.Context, *connect.Request[v1.EnqueueRemoteRequest]) (*connect.Response[v1.EnqueueRemoteResponse], error)
	// RouteQueueMessage delivers a queue message to a consumer on a different node.
	RouteQueueMessage(context.Context, *connect.Request[v1.RouteQueueMessageRequest]) (*connect.Response[v1.RouteQueueMessageResponse], error)
	// RouteQueueBatch delivers multiple queue messages in one RPC.
	RouteQueueBatch(context.Context, *connect.Request[v1.RouteQueueBatchRequest]) (*connect.Response[v1.RouteQueueBatchResponse], error)
	// AppendEntries is invoked by the Raft leader to replicate log entries.
	AppendEntries(context.Context, *connect.Request[v1.AppendEntriesRequest]) (*connect.Response[v1.AppendEntriesResponse], error)
	// RequestVote is invoked by candidates during leader election.
	RequestVote(context.Context, *connect.Request[v1.RequestVoteRequest]) (*connect.Response[v1.RequestVoteResponse], error)
	// InstallSnapshot is invoked by leader to transfer snapshot to a follower.
	InstallSnapshot(context.Context, *connect.Request[v1.InstallSnapshotRequest]) (*connect.Response[v1.InstallSnapshotResponse], error)
	// ForwardGroupOp forwards a consumer group mutation from a follower to the
	// Raft leader for the queue's replication group. The leader applies the
	// operation through its coordinator so it goes through Raft consensus.
	ForwardGroupOp(context.Context, *connect.Request[v1.ForwardGroupOpRequest]) (*connect.Response[v1.ForwardGroupOpResponse], error)
}

// NewBrokerServiceClient constructs a client for the fluxmq.cluster.v1.BrokerService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewBrokerServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) BrokerServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	brokerServiceMethods := v1.File_cluster_v1_broker_proto.Services().ByName("BrokerService").Methods()
	return &brokerServiceClient{
		routePublish: connect.NewClient[v1.PublishRequest, v1.PublishResponse](
			httpClient,
			baseURL+BrokerServiceRoutePublishProcedure,
			connect.WithSchema(brokerServiceMethods.ByName("RoutePublish")),
			connect.WithClientOptions(opts...),
		),
		routePublishBatch: connect.NewClient[v1.PublishBatchRequest, v1.PublishBatchResponse](
			httpClient,
			baseURL+BrokerServiceRoutePublishBatchProcedure,
			connect.WithSchema(brokerServiceMethods.ByName("RoutePublishBatch")),
			connect.WithClientOptions(opts...),
		),
		takeoverSession: connect.NewClient[v1.TakeoverRequest, v1.TakeoverResponse](
			httpClient,
			baseURL+BrokerServiceTakeoverSessionProcedure,
			connect.WithSchema(brokerServiceMethods.ByName("TakeoverSession")),
			connect.WithClientOptions(opts...),
		),
		fetchRetained: connect.NewClient[v1.FetchRetainedRequest, v1.FetchRetainedResponse](
			httpClient,
			baseURL+BrokerServiceFetchRetainedProcedure,
			connect.WithSchema(brokerServiceMethods.ByName("FetchRetained")),
			connect.WithClientOptions(opts...),
		),
		fetchWill: connect.NewClient[v1.FetchWillRequest, v1.FetchWillResponse](
			httpClient,
			baseURL+BrokerServiceFetchWillProcedure,
			connect.WithSchema(brokerServiceMethods.ByName("FetchWill")),
			connect.WithClientOptions(opts...),
		),
		enqueueRemote: connect.NewClient[v1.EnqueueRemoteRequest, v1.EnqueueRemoteResponse](
			httpClient,
			baseURL+BrokerServiceEnqueueRemoteProcedure,
			connect.WithSchema(brokerServiceMethods.ByName("EnqueueRemote")),
			connect.WithClientOptions(opts...),
		),
		routeQueueMessage: connect.NewClient[v1.RouteQueueMessageRequest, v1.RouteQueueMessageResponse](
			httpClient,
			baseURL+BrokerServiceRouteQueueMessageProcedure,
			connect.WithSchema(brokerServiceMethods.ByName("RouteQueueMessage")),
			connect.WithClientOptions(opts...),
		),
		routeQueueBatch: connect.NewClient[v1.RouteQueueBatchRequest, v1.RouteQueueBatchResponse](
			httpClient,
			baseURL+BrokerServiceRouteQueueBatchProcedure,
			connect.WithSchema(brokerServiceMethods.ByName("RouteQueueBatch")),
			connect.WithClientOptions(opts...),
		),
		appendEntries: connect.NewClient[v1.AppendEntriesRequest, v1.AppendEntriesResponse](
			httpClient,
			baseURL+BrokerServiceAppendEntriesProcedure,
			connect.WithSchema(brokerServiceMethods.ByName("AppendEntries")),
			connect.WithClientOptions(opts...),
		),
		requestVote: connect.NewClient[v1.RequestVoteRequest, v1.RequestVoteResponse](
			httpClient,
			baseURL+BrokerServiceRequestVoteProcedure,
			connect.WithSchema(brokerServiceMethods.ByName("RequestVote")),
			connect.WithClientOptions(opts...),
		),
		installSnapshot: connect.NewClient[v1.InstallSnapshotRequest, v1.InstallSnapshotResponse](
			httpClient,
			baseURL+BrokerServiceInstallSnapshotProcedure,
			connect.WithSchema(brokerServiceMethods.ByName("InstallSnapshot")),
			connect.WithClientOptions(opts...),
		),
		forwardGroupOp: connect.NewClient[v1.ForwardGroupOpRequest, v1.ForwardGroupOpResponse](
			httpClient,
			baseURL+BrokerServiceForwardGroupOpProcedure,
			connect.WithSchema(brokerServiceMethods.ByName("ForwardGroupOp")),
			connect.WithClientOptions(opts...),
		),
	}
}

// brokerServiceClient implements BrokerServiceClient.
type brokerServiceClient struct {
	routePublish      *connect.Client[v1.PublishRequest, v1.PublishResponse]
	routePublishBatch *connect.Client[v1.PublishBatchRequest, v1.PublishBatchResponse]
	takeoverSession   *connect.Client[v1.TakeoverRequest, v1.TakeoverResponse]
	fetchRetained     *connect.Client[v1.FetchRetainedRequest, v1.FetchRetainedResponse]
	fetchWill         *connect.Client[v1.FetchWillRequest, v1.FetchWillResponse]
	enqueueRemote     *connect.Client[v1.EnqueueRemoteRequest, v1.EnqueueRemoteResponse]
	routeQueueMessage *connect.Client[v1.RouteQueueMessageRequest, v1.RouteQueueMessageResponse]
	routeQueueBatch   *connect.Client[v1.RouteQueueBatchRequest, v1.RouteQueueBatchResponse]
	appendEntries     *connect.Client[v1.AppendEntriesRequest, v1.AppendEntriesResponse]
	requestVote       *connect.Client[v1.RequestVoteRequest, v1.RequestVoteResponse]
	installSnapshot   *connect.Client[v1.InstallSnapshotRequest, v1.InstallSnapshotResponse]
	forwardGroupOp    *connect.Client[v1.ForwardGroupOpRequest, v1.ForwardGroupOpResponse]
}

// RoutePublish calls fluxmq.cluster.v1.BrokerService.RoutePublish.
func (c *brokerServiceClient) RoutePublish(ctx context.Context, req *connect.Request[v1.PublishRequest]) (*connect.Response[v1.PublishResponse], error) {
	return c.routePublish.CallUnary(ctx, req)
}

// RoutePublishBatch calls fluxmq.cluster.v1.BrokerService.RoutePublishBatch.
func (c *brokerServiceClient) RoutePublishBatch(ctx context.Context, req *connect.Request[v1.PublishBatchRequest]) (*connect.Response[v1.PublishBatchResponse], error) {
	return c.routePublishBatch.CallUnary(ctx, req)
}

// TakeoverSession calls fluxmq.cluster.v1.BrokerService.TakeoverSession.
func (c *brokerServiceClient) TakeoverSession(ctx context.Context, req *connect.Request[v1.TakeoverRequest]) (*connect.Response[v1.TakeoverResponse], error) {
	return c.takeoverSession.CallUnary(ctx, req)
}

// FetchRetained calls fluxmq.cluster.v1.BrokerService.FetchRetained.
func (c *brokerServiceClient) FetchRetained(ctx context.Context, req *connect.Request[v1.FetchRetainedRequest]) (*connect.Response[v1.FetchRetainedResponse], error) {
	return c.fetchRetained.CallUnary(ctx, req)
}

// FetchWill calls fluxmq.cluster.v1.BrokerService.FetchWill.
func (c *brokerServiceClient) FetchWill(ctx context.Context, req *connect.Request[v1.FetchWillRequest]) (*connect.Response[v1.FetchWillResponse], error) {
	return c.fetchWill.CallUnary(ctx, req)
}

// EnqueueRemote calls fluxmq.cluster.v1.BrokerService.EnqueueRemote.
func (c *brokerServiceClient) EnqueueRemote(ctx context.Context, req *connect.Request[v1.EnqueueRemoteRequest]) (*connect.Response[v1.EnqueueRemoteResponse], error) {
	return c.enqueueRemote.CallUnary(ctx, req)
}

// RouteQueueMessage calls fluxmq.cluster.v1.BrokerService.RouteQueueMessage.
func (c *brokerServiceClient) RouteQueueMessage(ctx context.Context, req *connect.Request[v1.RouteQueueMessageRequest]) (*connect.Response[v1.RouteQueueMessageResponse], error) {
	return c.routeQueueMessage.CallUnary(ctx, req)
}

// RouteQueueBatch calls fluxmq.cluster.v1.BrokerService.RouteQueueBatch.
func (c *brokerServiceClient) RouteQueueBatch(ctx context.Context, req *connect.Request[v1.RouteQueueBatchRequest]) (*connect.Response[v1.RouteQueueBatchResponse], error) {
	return c.routeQueueBatch.CallUnary(ctx, req)
}

// AppendEntries calls fluxmq.cluster.v1.BrokerService.AppendEntries.
func (c *brokerServiceClient) AppendEntries(ctx context.Context, req *connect.Request[v1.AppendEntriesRequest]) (*connect.Response[v1.AppendEntriesResponse], error) {
	return c.appendEntries.CallUnary(ctx, req)
}

// RequestVote calls fluxmq.cluster.v1.BrokerService.RequestVote.
func (c *brokerServiceClient) RequestVote(ctx context.Context, req *connect.Request[v1.RequestVoteRequest]) (*connect.Response[v1.RequestVoteResponse], error) {
	return c.requestVote.CallUnary(ctx, req)
}

// InstallSnapshot calls fluxmq.cluster.v1.BrokerService.InstallSnapshot.
func (c *brokerServiceClient) InstallSnapshot(ctx context.Context, req *connect.Request[v1.InstallSnapshotRequest]) (*connect.Response[v1.InstallSnapshotResponse], error) {
	return c.installSnapshot.CallUnary(ctx, req)
}

// ForwardGroupOp calls fluxmq.cluster.v1.BrokerService.ForwardGroupOp.
func (c *brokerServiceClient) ForwardGroupOp(ctx context.Context, req *connect.Request[v1.ForwardGroupOpRequest]) (*connect.Response[v1.ForwardGroupOpResponse], error) {
	return c.forwardGroupOp.CallUnary(ctx, req)
}

// BrokerServiceHandler is an implementation of the fluxmq.cluster.v1.BrokerService service.
type BrokerServiceHandler interface {
	// RoutePublish forwards a PUBLISH packet to the broker that owns the target session.
	RoutePublish(context.Context, *connect.Request[v1.PublishRequest]) (*connect.Response[v1.PublishResponse], error)
	// RoutePublishBatch forwards multiple PUBLISH packets in one RPC.
	RoutePublishBatch(context.Context, *connect.Request[v1.PublishBatchRequest]) (*connect.Response[v1.PublishBatchResponse], error)
	// TakeoverSession migrates a session from one broker to another.
	TakeoverSession(context.Context, *connect.Request[v1.TakeoverRequest]) (*connect.Response[v1.TakeoverResponse], error)
	// FetchRetained fetches a retained message payload from the owning broker node.
	FetchRetained(context.Context, *connect.Request[v1.FetchRetainedRequest]) (*connect.Response[v1.FetchRetainedResponse], error)
	// FetchWill fetches a will message payload from the owning broker node.
	FetchWill(context.Context, *connect.Request[v1.FetchWillRequest]) (*connect.Response[v1.FetchWillResponse], error)
	// EnqueueRemote routes an enqueue operation to the remote node.
	EnqueueRemote(context.Context, *connect.Request[v1.EnqueueRemoteRequest]) (*connect.Response[v1.EnqueueRemoteResponse], error)
	// RouteQueueMessage delivers a queue message to a consumer on a different node.
	RouteQueueMessage(context.Context, *connect.Request[v1.RouteQueueMessageRequest]) (*connect.Response[v1.RouteQueueMessageResponse], error)
	// RouteQueueBatch delivers multiple queue messages in one RPC.
	RouteQueueBatch(context.Context, *connect.Request[v1.RouteQueueBatchRequest]) (*connect.Response[v1.RouteQueueBatchResponse], error)
	// AppendEntries is invoked by the Raft leader to replicate log entries.
	AppendEntries(context.Context, *connect.Request[v1.AppendEntriesRequest]) (*connect.Response[v1.AppendEntriesResponse], error)
	// RequestVote is invoked by candidates during leader election.
	RequestVote(context.Context, *connect.Request[v1.RequestVoteRequest]) (*connect.Response[v1.RequestVoteResponse], error)
	// InstallSnapshot is invoked by leader to transfer snapshot to a follower.
	InstallSnapshot(context.Context, *connect.Request[v1.InstallSnapshotRequest]) (*connect.Response[v1.InstallSnapshotResponse], error)
	// ForwardGroupOp forwards a consumer group mutation from a follower to the
	// Raft leader for the queue's replication group. The leader applies the
	// operation through its coordinator so it goes through Raft consensus.
	ForwardGroupOp(context.Context, *connect.Request[v1.ForwardGroupOpRequest]) (*connect.Response[v1.ForwardGroupOpResponse], error)
}

// NewBrokerServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewBrokerServiceHandler(svc BrokerServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	brokerServiceMethods := v1.File_cluster_v1_broker_proto.Services().ByName("BrokerService").Methods()
	brokerServiceRoutePublishHandler := connect.NewUnaryHandler(
		BrokerServiceRoutePublishProcedure,
		svc.RoutePublish,
		connect.WithSchema(brokerServiceMethods.ByName("RoutePublish")),
		connect.WithHandlerOptions(opts...),
	)
	brokerServiceRoutePublishBatchHandler := connect.NewUnaryHandler(
		BrokerServiceRoutePublishBatchProcedure,
		svc.RoutePublishBatch,
		connect.WithSchema(brokerServiceMethods.ByName("RoutePublishBatch")),
		connect.WithHandlerOptions(opts...),
	)
	brokerServiceTakeoverSessionHandler := connect.NewUnaryHandler(
		BrokerServiceTakeoverSessionProcedure,
		svc.TakeoverSession,
		connect.WithSchema(brokerServiceMethods.ByName("TakeoverSession")),
		connect.WithHandlerOptions(opts...),
	)
	brokerServiceFetchRetainedHandler := connect.NewUnaryHandler(
		BrokerServiceFetchRetainedProcedure,
		svc.FetchRetained,
		connect.WithSchema(brokerServiceMethods.ByName("FetchRetained")),
		connect.WithHandlerOptions(opts...),
	)
	brokerServiceFetchWillHandler := connect.NewUnaryHandler(
		BrokerServiceFetchWillProcedure,
		svc.FetchWill,
		connect.WithSchema(brokerServiceMethods.ByName("FetchWill")),
		connect.WithHandlerOptions(opts...),
	)
	brokerServiceEnqueueRemoteHandler := connect.NewUnaryHandler(
		BrokerServiceEnqueueRemoteProcedure,
		svc.EnqueueRemote,
		connect.WithSchema(brokerServiceMethods.ByName("EnqueueRemote")),
		connect.WithHandlerOptions(opts...),
	)
	brokerServiceRouteQueueMessageHandler := connect.NewUnaryHandler(
		BrokerServiceRouteQueueMessageProcedure,
		svc.RouteQueueMessage,
		connect.WithSchema(brokerServiceMethods.ByName("RouteQueueMessage")),
		connect.WithHandlerOptions(opts...),
	)
	brokerServiceRouteQueueBatchHandler := connect.NewUnaryHandler(
		BrokerServiceRouteQueueBatchProcedure,
		svc.RouteQueueBatch,
		connect.WithSchema(brokerServiceMethods.ByName("RouteQueueBatch")),
		connect.WithHandlerOptions(opts...),
	)
	brokerServiceAppendEntriesHandler := connect.NewUnaryHandler(
		BrokerServiceAppendEntriesProcedure,
		svc.AppendEntries,
		connect.WithSchema(brokerServiceMethods.ByName("AppendEntries")),
		connect.WithHandlerOptions(opts...),
	)
	brokerServiceRequestVoteHandler := connect.NewUnaryHandler(
		BrokerServiceRequestVoteProcedure,
		svc.RequestVote,
		connect.WithSchema(brokerServiceMethods.ByName("RequestVote")),
		connect.WithHandlerOptions(opts...),
	)
	brokerServiceInstallSnapshotHandler := connect.NewUnaryHandler(
		BrokerServiceInstallSnapshotProcedure,
		svc.InstallSnapshot,
		connect.WithSchema(brokerServiceMethods.ByName("InstallSnapshot")),
		connect.WithHandlerOptions(opts...),
	)
	brokerServiceForwardGroupOpHandler := connect.NewUnaryHandler(
		BrokerServiceForwardGroupOpProcedure,
		svc.ForwardGroupOp,
		connect.WithSchema(brokerServiceMethods.ByName("ForwardGroupOp")),
		connect.WithHandlerOptions(opts...),
	)
	return "/fluxmq.cluster.v1.BrokerService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case BrokerServiceRoutePublishProcedure:
			brokerServiceRoutePublishHandler.ServeHTTP(w, r)
		case BrokerServiceRoutePublishBatchProcedure:
			brokerServiceRoutePublishBatchHandler.ServeHTTP(w, r)
		case BrokerServiceTakeoverSessionProcedure:
			brokerServiceTakeoverSessionHandler.ServeHTTP(w, r)
		case BrokerServiceFetchRetainedProcedure:
			brokerServiceFetchRetainedHandler.ServeHTTP(w, r)
		case BrokerServiceFetchWillProcedure:
			brokerServiceFetchWillHandler.ServeHTTP(w, r)
		case BrokerServiceEnqueueRemoteProcedure:
			brokerServiceEnqueueRemoteHandler.ServeHTTP(w, r)
		case BrokerServiceRouteQueueMessageProcedure:
			brokerServiceRouteQueueMessageHandler.ServeHTTP(w, r)
		case BrokerServiceRouteQueueBatchProcedure:
			brokerServiceRouteQueueBatchHandler.ServeHTTP(w, r)
		case BrokerServiceAppendEntriesProcedure:
			brokerServiceAppendEntriesHandler.ServeHTTP(w, r)
		case BrokerServiceRequestVoteProcedure:
			brokerServiceRequestVoteHandler.ServeHTTP(w, r)
		case BrokerServiceInstallSnapshotProcedure:
			brokerServiceInstallSnapshotHandler.ServeHTTP(w, r)
		case BrokerServiceForwardGroupOpProcedure:
			brokerServiceForwardGroupOpHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedBrokerServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedBrokerServiceHandler struct{}

func (UnimplementedBrokerServiceHandler) RoutePublish(context.Context, *connect.Request[v1.PublishRequest]) (*connect.Response[v1.PublishResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.cluster.v1.BrokerService.RoutePublish is not implemented"))
}

func (UnimplementedBrokerServiceHandler) RoutePublishBatch(context.Context, *connect.Request[v1.PublishBatchRequest]) (*connect.Response[v1.PublishBatchResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.cluster.v1.BrokerService.RoutePublishBatch is not implemented"))
}

func (UnimplementedBrokerServiceHandler) TakeoverSession(context.Context, *connect.Request[v1.TakeoverRequest]) (*connect.Response[v1.TakeoverResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.cluster.v1.BrokerService.TakeoverSession is not implemented"))
}

func (UnimplementedBrokerServiceHandler) FetchRetained(context.Context, *connect.Request[v1.FetchRetainedRequest]) (*connect.Response[v1.FetchRetainedResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.cluster.v1.BrokerService.FetchRetained is not implemented"))
}

func (UnimplementedBrokerServiceHandler) FetchWill(context.Context, *connect.Request[v1.FetchWillRequest]) (*connect.Response[v1.FetchWillResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.cluster.v1.BrokerService.FetchWill is not implemented"))
}

func (UnimplementedBrokerServiceHandler) EnqueueRemote(context.Context, *connect.Request[v1.EnqueueRemoteRequest]) (*connect.Response[v1.EnqueueRemoteResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.cluster.v1.BrokerService.EnqueueRemote is not implemented"))
}

func (UnimplementedBrokerServiceHandler) RouteQueueMessage(context.Context, *connect.Request[v1.RouteQueueMessageRequest]) (*connect.Response[v1.RouteQueueMessageResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.cluster.v1.BrokerService.RouteQueueMessage is not implemented"))
}

func (UnimplementedBrokerServiceHandler) RouteQueueBatch(context.Context, *connect.Request[v1.RouteQueueBatchRequest]) (*connect.Response[v1.RouteQueueBatchResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.cluster.v1.BrokerService.RouteQueueBatch is not implemented"))
}

func (UnimplementedBrokerServiceHandler) AppendEntries(context.Context, *connect.Request[v1.AppendEntriesRequest]) (*connect.Response[v1.AppendEntriesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.cluster.v1.BrokerService.AppendEntries is not implemented"))
}

func (UnimplementedBrokerServiceHandler) RequestVote(context.Context, *connect.Request[v1.RequestVoteRequest]) (*connect.Response[v1.RequestVoteResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.cluster.v1.BrokerService.RequestVote is not implemented"))
}

func (UnimplementedBrokerServiceHandler) InstallSnapshot(context.Context, *connect.Request[v1.InstallSnapshotRequest]) (*connect.Response[v1.InstallSnapshotResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.cluster.v1.BrokerService.InstallSnapshot is not implemented"))
}

func (UnimplementedBrokerServiceHandler) ForwardGroupOp(context.Context, *connect.Request[v1.ForwardGroupOpRequest]) (*connect.Response[v1.ForwardGroupOpResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.cluster.v1.BrokerService.ForwardGroupOp is not implemented"))
}
