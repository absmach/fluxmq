// Copyright (c) Abstract Machines
// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: queue/v1/queue.proto

package queuev1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/absmach/fluxmq/pkg/proto/queue/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// QueueServiceName is the fully-qualified name of the QueueService service.
	QueueServiceName = "fluxmq.queue.v1.QueueService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// QueueServiceCreateQueueProcedure is the fully-qualified name of the QueueService's CreateQueue
	// RPC.
	QueueServiceCreateQueueProcedure = "/fluxmq.queue.v1.QueueService/CreateQueue"
	// QueueServiceGetQueueProcedure is the fully-qualified name of the QueueService's GetQueue RPC.
	QueueServiceGetQueueProcedure = "/fluxmq.queue.v1.QueueService/GetQueue"
	// QueueServiceListQueuesProcedure is the fully-qualified name of the QueueService's ListQueues RPC.
	QueueServiceListQueuesProcedure = "/fluxmq.queue.v1.QueueService/ListQueues"
	// QueueServiceDeleteQueueProcedure is the fully-qualified name of the QueueService's DeleteQueue
	// RPC.
	QueueServiceDeleteQueueProcedure = "/fluxmq.queue.v1.QueueService/DeleteQueue"
	// QueueServiceUpdateQueueProcedure is the fully-qualified name of the QueueService's UpdateQueue
	// RPC.
	QueueServiceUpdateQueueProcedure = "/fluxmq.queue.v1.QueueService/UpdateQueue"
	// QueueServiceAppendProcedure is the fully-qualified name of the QueueService's Append RPC.
	QueueServiceAppendProcedure = "/fluxmq.queue.v1.QueueService/Append"
	// QueueServiceAppendBatchProcedure is the fully-qualified name of the QueueService's AppendBatch
	// RPC.
	QueueServiceAppendBatchProcedure = "/fluxmq.queue.v1.QueueService/AppendBatch"
	// QueueServiceAppendStreamProcedure is the fully-qualified name of the QueueService's AppendStream
	// RPC.
	QueueServiceAppendStreamProcedure = "/fluxmq.queue.v1.QueueService/AppendStream"
	// QueueServiceReadProcedure is the fully-qualified name of the QueueService's Read RPC.
	QueueServiceReadProcedure = "/fluxmq.queue.v1.QueueService/Read"
	// QueueServiceReadBatchProcedure is the fully-qualified name of the QueueService's ReadBatch RPC.
	QueueServiceReadBatchProcedure = "/fluxmq.queue.v1.QueueService/ReadBatch"
	// QueueServiceTailProcedure is the fully-qualified name of the QueueService's Tail RPC.
	QueueServiceTailProcedure = "/fluxmq.queue.v1.QueueService/Tail"
	// QueueServiceSeekToOffsetProcedure is the fully-qualified name of the QueueService's SeekToOffset
	// RPC.
	QueueServiceSeekToOffsetProcedure = "/fluxmq.queue.v1.QueueService/SeekToOffset"
	// QueueServiceSeekToTimestampProcedure is the fully-qualified name of the QueueService's
	// SeekToTimestamp RPC.
	QueueServiceSeekToTimestampProcedure = "/fluxmq.queue.v1.QueueService/SeekToTimestamp"
	// QueueServiceCreateConsumerGroupProcedure is the fully-qualified name of the QueueService's
	// CreateConsumerGroup RPC.
	QueueServiceCreateConsumerGroupProcedure = "/fluxmq.queue.v1.QueueService/CreateConsumerGroup"
	// QueueServiceGetConsumerGroupProcedure is the fully-qualified name of the QueueService's
	// GetConsumerGroup RPC.
	QueueServiceGetConsumerGroupProcedure = "/fluxmq.queue.v1.QueueService/GetConsumerGroup"
	// QueueServiceListConsumerGroupsProcedure is the fully-qualified name of the QueueService's
	// ListConsumerGroups RPC.
	QueueServiceListConsumerGroupsProcedure = "/fluxmq.queue.v1.QueueService/ListConsumerGroups"
	// QueueServiceDeleteConsumerGroupProcedure is the fully-qualified name of the QueueService's
	// DeleteConsumerGroup RPC.
	QueueServiceDeleteConsumerGroupProcedure = "/fluxmq.queue.v1.QueueService/DeleteConsumerGroup"
	// QueueServiceJoinGroupProcedure is the fully-qualified name of the QueueService's JoinGroup RPC.
	QueueServiceJoinGroupProcedure = "/fluxmq.queue.v1.QueueService/JoinGroup"
	// QueueServiceLeaveGroupProcedure is the fully-qualified name of the QueueService's LeaveGroup RPC.
	QueueServiceLeaveGroupProcedure = "/fluxmq.queue.v1.QueueService/LeaveGroup"
	// QueueServiceHeartbeatProcedure is the fully-qualified name of the QueueService's Heartbeat RPC.
	QueueServiceHeartbeatProcedure = "/fluxmq.queue.v1.QueueService/Heartbeat"
	// QueueServiceConsumeProcedure is the fully-qualified name of the QueueService's Consume RPC.
	QueueServiceConsumeProcedure = "/fluxmq.queue.v1.QueueService/Consume"
	// QueueServiceConsumeStreamProcedure is the fully-qualified name of the QueueService's
	// ConsumeStream RPC.
	QueueServiceConsumeStreamProcedure = "/fluxmq.queue.v1.QueueService/ConsumeStream"
	// QueueServiceAckProcedure is the fully-qualified name of the QueueService's Ack RPC.
	QueueServiceAckProcedure = "/fluxmq.queue.v1.QueueService/Ack"
	// QueueServiceNackProcedure is the fully-qualified name of the QueueService's Nack RPC.
	QueueServiceNackProcedure = "/fluxmq.queue.v1.QueueService/Nack"
	// QueueServiceClaimProcedure is the fully-qualified name of the QueueService's Claim RPC.
	QueueServiceClaimProcedure = "/fluxmq.queue.v1.QueueService/Claim"
	// QueueServiceGetPendingProcedure is the fully-qualified name of the QueueService's GetPending RPC.
	QueueServiceGetPendingProcedure = "/fluxmq.queue.v1.QueueService/GetPending"
	// QueueServiceGetQueueInfoProcedure is the fully-qualified name of the QueueService's GetQueueInfo
	// RPC.
	QueueServiceGetQueueInfoProcedure = "/fluxmq.queue.v1.QueueService/GetQueueInfo"
	// QueueServiceGetStatsProcedure is the fully-qualified name of the QueueService's GetStats RPC.
	QueueServiceGetStatsProcedure = "/fluxmq.queue.v1.QueueService/GetStats"
	// QueueServicePurgeProcedure is the fully-qualified name of the QueueService's Purge RPC.
	QueueServicePurgeProcedure = "/fluxmq.queue.v1.QueueService/Purge"
	// QueueServiceTruncateProcedure is the fully-qualified name of the QueueService's Truncate RPC.
	QueueServiceTruncateProcedure = "/fluxmq.queue.v1.QueueService/Truncate"
)

// QueueServiceClient is a client for the fluxmq.queue.v1.QueueService service.
type QueueServiceClient interface {
	// CreateQueue creates a new queue with the specified configuration.
	CreateQueue(context.Context, *connect.Request[v1.CreateQueueRequest]) (*connect.Response[v1.Queue], error)
	// GetQueue retrieves queue metadata and current state.
	GetQueue(context.Context, *connect.Request[v1.GetQueueRequest]) (*connect.Response[v1.Queue], error)
	// ListQueues returns all queues, with optional filtering.
	ListQueues(context.Context, *connect.Request[v1.ListQueuesRequest]) (*connect.Response[v1.ListQueuesResponse], error)
	// DeleteQueue removes a queue and all its data.
	DeleteQueue(context.Context, *connect.Request[v1.DeleteQueueRequest]) (*connect.Response[emptypb.Empty], error)
	// UpdateQueue updates queue configuration (retention, limits, etc).
	UpdateQueue(context.Context, *connect.Request[v1.UpdateQueueRequest]) (*connect.Response[v1.Queue], error)
	// Append adds a single message to a queue. Returns the assigned offset.
	Append(context.Context, *connect.Request[v1.AppendRequest]) (*connect.Response[v1.AppendResponse], error)
	// AppendBatch adds multiple messages atomically.
	AppendBatch(context.Context, *connect.Request[v1.AppendBatchRequest]) (*connect.Response[v1.AppendBatchResponse], error)
	// AppendStream allows streaming multiple messages.
	AppendStream(context.Context) *connect.ClientStreamForClient[v1.AppendRequest, v1.AppendBatchResponse]
	// Read fetches a single message at a specific offset.
	Read(context.Context, *connect.Request[v1.ReadRequest]) (*connect.Response[v1.Message], error)
	// ReadBatch fetches multiple messages starting from an offset.
	ReadBatch(context.Context, *connect.Request[v1.ReadBatchRequest]) (*connect.Response[v1.ReadBatchResponse], error)
	// Tail streams new messages as they arrive (server-side streaming).
	// Starts from specified offset and continues indefinitely.
	Tail(context.Context, *connect.Request[v1.TailRequest]) (*connect.ServerStreamForClient[v1.Message], error)
	// SeekToOffset returns queue state at a given offset.
	SeekToOffset(context.Context, *connect.Request[v1.SeekToOffsetRequest]) (*connect.Response[v1.SeekResponse], error)
	// SeekToTimestamp finds the offset closest to a timestamp.
	SeekToTimestamp(context.Context, *connect.Request[v1.SeekToTimestampRequest]) (*connect.Response[v1.SeekResponse], error)
	// CreateConsumerGroup creates a new consumer group for a queue.
	CreateConsumerGroup(context.Context, *connect.Request[v1.CreateConsumerGroupRequest]) (*connect.Response[v1.ConsumerGroup], error)
	// GetConsumerGroup retrieves consumer group state.
	GetConsumerGroup(context.Context, *connect.Request[v1.GetConsumerGroupRequest]) (*connect.Response[v1.ConsumerGroup], error)
	// ListConsumerGroups lists all consumer groups for a queue.
	ListConsumerGroups(context.Context, *connect.Request[v1.ListConsumerGroupsRequest]) (*connect.Response[v1.ListConsumerGroupsResponse], error)
	// DeleteConsumerGroup removes a consumer group.
	DeleteConsumerGroup(context.Context, *connect.Request[v1.DeleteConsumerGroupRequest]) (*connect.Response[emptypb.Empty], error)
	// JoinGroup adds a consumer to a group.
	JoinGroup(context.Context, *connect.Request[v1.JoinGroupRequest]) (*connect.Response[v1.JoinGroupResponse], error)
	// LeaveGroup removes a consumer from a group.
	LeaveGroup(context.Context, *connect.Request[v1.LeaveGroupRequest]) (*connect.Response[emptypb.Empty], error)
	// Heartbeat keeps consumer session alive and receives rebalance notifications.
	Heartbeat(context.Context, *connect.Request[v1.HeartbeatRequest]) (*connect.Response[v1.HeartbeatResponse], error)
	// Consume fetches the next batch of messages for a consumer.
	// Messages are tracked in the Pending Entry List (PEL) until acknowledged.
	Consume(context.Context, *connect.Request[v1.ConsumeRequest]) (*connect.Response[v1.ConsumeResponse], error)
	// ConsumeStream continuously delivers messages to a consumer (server streaming).
	ConsumeStream(context.Context, *connect.Request[v1.ConsumeStreamRequest]) (*connect.ServerStreamForClient[v1.Message], error)
	// Ack acknowledges successful processing of messages.
	Ack(context.Context, *connect.Request[v1.AckRequest]) (*connect.Response[v1.AckResponse], error)
	// Nack indicates processing failure. Messages will be redelivered.
	Nack(context.Context, *connect.Request[v1.NackRequest]) (*connect.Response[emptypb.Empty], error)
	// Claim transfers pending messages from one consumer to another (work stealing).
	Claim(context.Context, *connect.Request[v1.ClaimRequest]) (*connect.Response[v1.ClaimResponse], error)
	// GetPending retrieves pending (unacknowledged) messages for a consumer or group.
	GetPending(context.Context, *connect.Request[v1.GetPendingRequest]) (*connect.Response[v1.GetPendingResponse], error)
	// GetQueueInfo returns metadata for a queue.
	GetQueueInfo(context.Context, *connect.Request[v1.GetQueueInfoRequest]) (*connect.Response[v1.QueueInfo], error)
	// GetStats returns queue statistics.
	GetStats(context.Context, *connect.Request[v1.GetStatsRequest]) (*connect.Response[v1.QueueStats], error)
	// Purge removes all messages from a queue.
	Purge(context.Context, *connect.Request[v1.PurgeRequest]) (*connect.Response[v1.PurgeResponse], error)
	// Truncate removes messages before a given offset (retention enforcement).
	Truncate(context.Context, *connect.Request[v1.TruncateRequest]) (*connect.Response[emptypb.Empty], error)
}

// NewQueueServiceClient constructs a client for the fluxmq.queue.v1.QueueService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewQueueServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) QueueServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	queueServiceMethods := v1.File_queue_v1_queue_proto.Services().ByName("QueueService").Methods()
	return &queueServiceClient{
		createQueue: connect.NewClient[v1.CreateQueueRequest, v1.Queue](
			httpClient,
			baseURL+QueueServiceCreateQueueProcedure,
			connect.WithSchema(queueServiceMethods.ByName("CreateQueue")),
			connect.WithClientOptions(opts...),
		),
		getQueue: connect.NewClient[v1.GetQueueRequest, v1.Queue](
			httpClient,
			baseURL+QueueServiceGetQueueProcedure,
			connect.WithSchema(queueServiceMethods.ByName("GetQueue")),
			connect.WithClientOptions(opts...),
		),
		listQueues: connect.NewClient[v1.ListQueuesRequest, v1.ListQueuesResponse](
			httpClient,
			baseURL+QueueServiceListQueuesProcedure,
			connect.WithSchema(queueServiceMethods.ByName("ListQueues")),
			connect.WithClientOptions(opts...),
		),
		deleteQueue: connect.NewClient[v1.DeleteQueueRequest, emptypb.Empty](
			httpClient,
			baseURL+QueueServiceDeleteQueueProcedure,
			connect.WithSchema(queueServiceMethods.ByName("DeleteQueue")),
			connect.WithClientOptions(opts...),
		),
		updateQueue: connect.NewClient[v1.UpdateQueueRequest, v1.Queue](
			httpClient,
			baseURL+QueueServiceUpdateQueueProcedure,
			connect.WithSchema(queueServiceMethods.ByName("UpdateQueue")),
			connect.WithClientOptions(opts...),
		),
		append: connect.NewClient[v1.AppendRequest, v1.AppendResponse](
			httpClient,
			baseURL+QueueServiceAppendProcedure,
			connect.WithSchema(queueServiceMethods.ByName("Append")),
			connect.WithClientOptions(opts...),
		),
		appendBatch: connect.NewClient[v1.AppendBatchRequest, v1.AppendBatchResponse](
			httpClient,
			baseURL+QueueServiceAppendBatchProcedure,
			connect.WithSchema(queueServiceMethods.ByName("AppendBatch")),
			connect.WithClientOptions(opts...),
		),
		appendStream: connect.NewClient[v1.AppendRequest, v1.AppendBatchResponse](
			httpClient,
			baseURL+QueueServiceAppendStreamProcedure,
			connect.WithSchema(queueServiceMethods.ByName("AppendStream")),
			connect.WithClientOptions(opts...),
		),
		read: connect.NewClient[v1.ReadRequest, v1.Message](
			httpClient,
			baseURL+QueueServiceReadProcedure,
			connect.WithSchema(queueServiceMethods.ByName("Read")),
			connect.WithClientOptions(opts...),
		),
		readBatch: connect.NewClient[v1.ReadBatchRequest, v1.ReadBatchResponse](
			httpClient,
			baseURL+QueueServiceReadBatchProcedure,
			connect.WithSchema(queueServiceMethods.ByName("ReadBatch")),
			connect.WithClientOptions(opts...),
		),
		tail: connect.NewClient[v1.TailRequest, v1.Message](
			httpClient,
			baseURL+QueueServiceTailProcedure,
			connect.WithSchema(queueServiceMethods.ByName("Tail")),
			connect.WithClientOptions(opts...),
		),
		seekToOffset: connect.NewClient[v1.SeekToOffsetRequest, v1.SeekResponse](
			httpClient,
			baseURL+QueueServiceSeekToOffsetProcedure,
			connect.WithSchema(queueServiceMethods.ByName("SeekToOffset")),
			connect.WithClientOptions(opts...),
		),
		seekToTimestamp: connect.NewClient[v1.SeekToTimestampRequest, v1.SeekResponse](
			httpClient,
			baseURL+QueueServiceSeekToTimestampProcedure,
			connect.WithSchema(queueServiceMethods.ByName("SeekToTimestamp")),
			connect.WithClientOptions(opts...),
		),
		createConsumerGroup: connect.NewClient[v1.CreateConsumerGroupRequest, v1.ConsumerGroup](
			httpClient,
			baseURL+QueueServiceCreateConsumerGroupProcedure,
			connect.WithSchema(queueServiceMethods.ByName("CreateConsumerGroup")),
			connect.WithClientOptions(opts...),
		),
		getConsumerGroup: connect.NewClient[v1.GetConsumerGroupRequest, v1.ConsumerGroup](
			httpClient,
			baseURL+QueueServiceGetConsumerGroupProcedure,
			connect.WithSchema(queueServiceMethods.ByName("GetConsumerGroup")),
			connect.WithClientOptions(opts...),
		),
		listConsumerGroups: connect.NewClient[v1.ListConsumerGroupsRequest, v1.ListConsumerGroupsResponse](
			httpClient,
			baseURL+QueueServiceListConsumerGroupsProcedure,
			connect.WithSchema(queueServiceMethods.ByName("ListConsumerGroups")),
			connect.WithClientOptions(opts...),
		),
		deleteConsumerGroup: connect.NewClient[v1.DeleteConsumerGroupRequest, emptypb.Empty](
			httpClient,
			baseURL+QueueServiceDeleteConsumerGroupProcedure,
			connect.WithSchema(queueServiceMethods.ByName("DeleteConsumerGroup")),
			connect.WithClientOptions(opts...),
		),
		joinGroup: connect.NewClient[v1.JoinGroupRequest, v1.JoinGroupResponse](
			httpClient,
			baseURL+QueueServiceJoinGroupProcedure,
			connect.WithSchema(queueServiceMethods.ByName("JoinGroup")),
			connect.WithClientOptions(opts...),
		),
		leaveGroup: connect.NewClient[v1.LeaveGroupRequest, emptypb.Empty](
			httpClient,
			baseURL+QueueServiceLeaveGroupProcedure,
			connect.WithSchema(queueServiceMethods.ByName("LeaveGroup")),
			connect.WithClientOptions(opts...),
		),
		heartbeat: connect.NewClient[v1.HeartbeatRequest, v1.HeartbeatResponse](
			httpClient,
			baseURL+QueueServiceHeartbeatProcedure,
			connect.WithSchema(queueServiceMethods.ByName("Heartbeat")),
			connect.WithClientOptions(opts...),
		),
		consume: connect.NewClient[v1.ConsumeRequest, v1.ConsumeResponse](
			httpClient,
			baseURL+QueueServiceConsumeProcedure,
			connect.WithSchema(queueServiceMethods.ByName("Consume")),
			connect.WithClientOptions(opts...),
		),
		consumeStream: connect.NewClient[v1.ConsumeStreamRequest, v1.Message](
			httpClient,
			baseURL+QueueServiceConsumeStreamProcedure,
			connect.WithSchema(queueServiceMethods.ByName("ConsumeStream")),
			connect.WithClientOptions(opts...),
		),
		ack: connect.NewClient[v1.AckRequest, v1.AckResponse](
			httpClient,
			baseURL+QueueServiceAckProcedure,
			connect.WithSchema(queueServiceMethods.ByName("Ack")),
			connect.WithClientOptions(opts...),
		),
		nack: connect.NewClient[v1.NackRequest, emptypb.Empty](
			httpClient,
			baseURL+QueueServiceNackProcedure,
			connect.WithSchema(queueServiceMethods.ByName("Nack")),
			connect.WithClientOptions(opts...),
		),
		claim: connect.NewClient[v1.ClaimRequest, v1.ClaimResponse](
			httpClient,
			baseURL+QueueServiceClaimProcedure,
			connect.WithSchema(queueServiceMethods.ByName("Claim")),
			connect.WithClientOptions(opts...),
		),
		getPending: connect.NewClient[v1.GetPendingRequest, v1.GetPendingResponse](
			httpClient,
			baseURL+QueueServiceGetPendingProcedure,
			connect.WithSchema(queueServiceMethods.ByName("GetPending")),
			connect.WithClientOptions(opts...),
		),
		getQueueInfo: connect.NewClient[v1.GetQueueInfoRequest, v1.QueueInfo](
			httpClient,
			baseURL+QueueServiceGetQueueInfoProcedure,
			connect.WithSchema(queueServiceMethods.ByName("GetQueueInfo")),
			connect.WithClientOptions(opts...),
		),
		getStats: connect.NewClient[v1.GetStatsRequest, v1.QueueStats](
			httpClient,
			baseURL+QueueServiceGetStatsProcedure,
			connect.WithSchema(queueServiceMethods.ByName("GetStats")),
			connect.WithClientOptions(opts...),
		),
		purge: connect.NewClient[v1.PurgeRequest, v1.PurgeResponse](
			httpClient,
			baseURL+QueueServicePurgeProcedure,
			connect.WithSchema(queueServiceMethods.ByName("Purge")),
			connect.WithClientOptions(opts...),
		),
		truncate: connect.NewClient[v1.TruncateRequest, emptypb.Empty](
			httpClient,
			baseURL+QueueServiceTruncateProcedure,
			connect.WithSchema(queueServiceMethods.ByName("Truncate")),
			connect.WithClientOptions(opts...),
		),
	}
}

// queueServiceClient implements QueueServiceClient.
type queueServiceClient struct {
	createQueue         *connect.Client[v1.CreateQueueRequest, v1.Queue]
	getQueue            *connect.Client[v1.GetQueueRequest, v1.Queue]
	listQueues          *connect.Client[v1.ListQueuesRequest, v1.ListQueuesResponse]
	deleteQueue         *connect.Client[v1.DeleteQueueRequest, emptypb.Empty]
	updateQueue         *connect.Client[v1.UpdateQueueRequest, v1.Queue]
	append              *connect.Client[v1.AppendRequest, v1.AppendResponse]
	appendBatch         *connect.Client[v1.AppendBatchRequest, v1.AppendBatchResponse]
	appendStream        *connect.Client[v1.AppendRequest, v1.AppendBatchResponse]
	read                *connect.Client[v1.ReadRequest, v1.Message]
	readBatch           *connect.Client[v1.ReadBatchRequest, v1.ReadBatchResponse]
	tail                *connect.Client[v1.TailRequest, v1.Message]
	seekToOffset        *connect.Client[v1.SeekToOffsetRequest, v1.SeekResponse]
	seekToTimestamp     *connect.Client[v1.SeekToTimestampRequest, v1.SeekResponse]
	createConsumerGroup *connect.Client[v1.CreateConsumerGroupRequest, v1.ConsumerGroup]
	getConsumerGroup    *connect.Client[v1.GetConsumerGroupRequest, v1.ConsumerGroup]
	listConsumerGroups  *connect.Client[v1.ListConsumerGroupsRequest, v1.ListConsumerGroupsResponse]
	deleteConsumerGroup *connect.Client[v1.DeleteConsumerGroupRequest, emptypb.Empty]
	joinGroup           *connect.Client[v1.JoinGroupRequest, v1.JoinGroupResponse]
	leaveGroup          *connect.Client[v1.LeaveGroupRequest, emptypb.Empty]
	heartbeat           *connect.Client[v1.HeartbeatRequest, v1.HeartbeatResponse]
	consume             *connect.Client[v1.ConsumeRequest, v1.ConsumeResponse]
	consumeStream       *connect.Client[v1.ConsumeStreamRequest, v1.Message]
	ack                 *connect.Client[v1.AckRequest, v1.AckResponse]
	nack                *connect.Client[v1.NackRequest, emptypb.Empty]
	claim               *connect.Client[v1.ClaimRequest, v1.ClaimResponse]
	getPending          *connect.Client[v1.GetPendingRequest, v1.GetPendingResponse]
	getQueueInfo        *connect.Client[v1.GetQueueInfoRequest, v1.QueueInfo]
	getStats            *connect.Client[v1.GetStatsRequest, v1.QueueStats]
	purge               *connect.Client[v1.PurgeRequest, v1.PurgeResponse]
	truncate            *connect.Client[v1.TruncateRequest, emptypb.Empty]
}

// CreateQueue calls fluxmq.queue.v1.QueueService.CreateQueue.
func (c *queueServiceClient) CreateQueue(ctx context.Context, req *connect.Request[v1.CreateQueueRequest]) (*connect.Response[v1.Queue], error) {
	return c.createQueue.CallUnary(ctx, req)
}

// GetQueue calls fluxmq.queue.v1.QueueService.GetQueue.
func (c *queueServiceClient) GetQueue(ctx context.Context, req *connect.Request[v1.GetQueueRequest]) (*connect.Response[v1.Queue], error) {
	return c.getQueue.CallUnary(ctx, req)
}

// ListQueues calls fluxmq.queue.v1.QueueService.ListQueues.
func (c *queueServiceClient) ListQueues(ctx context.Context, req *connect.Request[v1.ListQueuesRequest]) (*connect.Response[v1.ListQueuesResponse], error) {
	return c.listQueues.CallUnary(ctx, req)
}

// DeleteQueue calls fluxmq.queue.v1.QueueService.DeleteQueue.
func (c *queueServiceClient) DeleteQueue(ctx context.Context, req *connect.Request[v1.DeleteQueueRequest]) (*connect.Response[emptypb.Empty], error) {
	return c.deleteQueue.CallUnary(ctx, req)
}

// UpdateQueue calls fluxmq.queue.v1.QueueService.UpdateQueue.
func (c *queueServiceClient) UpdateQueue(ctx context.Context, req *connect.Request[v1.UpdateQueueRequest]) (*connect.Response[v1.Queue], error) {
	return c.updateQueue.CallUnary(ctx, req)
}

// Append calls fluxmq.queue.v1.QueueService.Append.
func (c *queueServiceClient) Append(ctx context.Context, req *connect.Request[v1.AppendRequest]) (*connect.Response[v1.AppendResponse], error) {
	return c.append.CallUnary(ctx, req)
}

// AppendBatch calls fluxmq.queue.v1.QueueService.AppendBatch.
func (c *queueServiceClient) AppendBatch(ctx context.Context, req *connect.Request[v1.AppendBatchRequest]) (*connect.Response[v1.AppendBatchResponse], error) {
	return c.appendBatch.CallUnary(ctx, req)
}

// AppendStream calls fluxmq.queue.v1.QueueService.AppendStream.
func (c *queueServiceClient) AppendStream(ctx context.Context) *connect.ClientStreamForClient[v1.AppendRequest, v1.AppendBatchResponse] {
	return c.appendStream.CallClientStream(ctx)
}

// Read calls fluxmq.queue.v1.QueueService.Read.
func (c *queueServiceClient) Read(ctx context.Context, req *connect.Request[v1.ReadRequest]) (*connect.Response[v1.Message], error) {
	return c.read.CallUnary(ctx, req)
}

// ReadBatch calls fluxmq.queue.v1.QueueService.ReadBatch.
func (c *queueServiceClient) ReadBatch(ctx context.Context, req *connect.Request[v1.ReadBatchRequest]) (*connect.Response[v1.ReadBatchResponse], error) {
	return c.readBatch.CallUnary(ctx, req)
}

// Tail calls fluxmq.queue.v1.QueueService.Tail.
func (c *queueServiceClient) Tail(ctx context.Context, req *connect.Request[v1.TailRequest]) (*connect.ServerStreamForClient[v1.Message], error) {
	return c.tail.CallServerStream(ctx, req)
}

// SeekToOffset calls fluxmq.queue.v1.QueueService.SeekToOffset.
func (c *queueServiceClient) SeekToOffset(ctx context.Context, req *connect.Request[v1.SeekToOffsetRequest]) (*connect.Response[v1.SeekResponse], error) {
	return c.seekToOffset.CallUnary(ctx, req)
}

// SeekToTimestamp calls fluxmq.queue.v1.QueueService.SeekToTimestamp.
func (c *queueServiceClient) SeekToTimestamp(ctx context.Context, req *connect.Request[v1.SeekToTimestampRequest]) (*connect.Response[v1.SeekResponse], error) {
	return c.seekToTimestamp.CallUnary(ctx, req)
}

// CreateConsumerGroup calls fluxmq.queue.v1.QueueService.CreateConsumerGroup.
func (c *queueServiceClient) CreateConsumerGroup(ctx context.Context, req *connect.Request[v1.CreateConsumerGroupRequest]) (*connect.Response[v1.ConsumerGroup], error) {
	return c.createConsumerGroup.CallUnary(ctx, req)
}

// GetConsumerGroup calls fluxmq.queue.v1.QueueService.GetConsumerGroup.
func (c *queueServiceClient) GetConsumerGroup(ctx context.Context, req *connect.Request[v1.GetConsumerGroupRequest]) (*connect.Response[v1.ConsumerGroup], error) {
	return c.getConsumerGroup.CallUnary(ctx, req)
}

// ListConsumerGroups calls fluxmq.queue.v1.QueueService.ListConsumerGroups.
func (c *queueServiceClient) ListConsumerGroups(ctx context.Context, req *connect.Request[v1.ListConsumerGroupsRequest]) (*connect.Response[v1.ListConsumerGroupsResponse], error) {
	return c.listConsumerGroups.CallUnary(ctx, req)
}

// DeleteConsumerGroup calls fluxmq.queue.v1.QueueService.DeleteConsumerGroup.
func (c *queueServiceClient) DeleteConsumerGroup(ctx context.Context, req *connect.Request[v1.DeleteConsumerGroupRequest]) (*connect.Response[emptypb.Empty], error) {
	return c.deleteConsumerGroup.CallUnary(ctx, req)
}

// JoinGroup calls fluxmq.queue.v1.QueueService.JoinGroup.
func (c *queueServiceClient) JoinGroup(ctx context.Context, req *connect.Request[v1.JoinGroupRequest]) (*connect.Response[v1.JoinGroupResponse], error) {
	return c.joinGroup.CallUnary(ctx, req)
}

// LeaveGroup calls fluxmq.queue.v1.QueueService.LeaveGroup.
func (c *queueServiceClient) LeaveGroup(ctx context.Context, req *connect.Request[v1.LeaveGroupRequest]) (*connect.Response[emptypb.Empty], error) {
	return c.leaveGroup.CallUnary(ctx, req)
}

// Heartbeat calls fluxmq.queue.v1.QueueService.Heartbeat.
func (c *queueServiceClient) Heartbeat(ctx context.Context, req *connect.Request[v1.HeartbeatRequest]) (*connect.Response[v1.HeartbeatResponse], error) {
	return c.heartbeat.CallUnary(ctx, req)
}

// Consume calls fluxmq.queue.v1.QueueService.Consume.
func (c *queueServiceClient) Consume(ctx context.Context, req *connect.Request[v1.ConsumeRequest]) (*connect.Response[v1.ConsumeResponse], error) {
	return c.consume.CallUnary(ctx, req)
}

// ConsumeStream calls fluxmq.queue.v1.QueueService.ConsumeStream.
func (c *queueServiceClient) ConsumeStream(ctx context.Context, req *connect.Request[v1.ConsumeStreamRequest]) (*connect.ServerStreamForClient[v1.Message], error) {
	return c.consumeStream.CallServerStream(ctx, req)
}

// Ack calls fluxmq.queue.v1.QueueService.Ack.
func (c *queueServiceClient) Ack(ctx context.Context, req *connect.Request[v1.AckRequest]) (*connect.Response[v1.AckResponse], error) {
	return c.ack.CallUnary(ctx, req)
}

// Nack calls fluxmq.queue.v1.QueueService.Nack.
func (c *queueServiceClient) Nack(ctx context.Context, req *connect.Request[v1.NackRequest]) (*connect.Response[emptypb.Empty], error) {
	return c.nack.CallUnary(ctx, req)
}

// Claim calls fluxmq.queue.v1.QueueService.Claim.
func (c *queueServiceClient) Claim(ctx context.Context, req *connect.Request[v1.ClaimRequest]) (*connect.Response[v1.ClaimResponse], error) {
	return c.claim.CallUnary(ctx, req)
}

// GetPending calls fluxmq.queue.v1.QueueService.GetPending.
func (c *queueServiceClient) GetPending(ctx context.Context, req *connect.Request[v1.GetPendingRequest]) (*connect.Response[v1.GetPendingResponse], error) {
	return c.getPending.CallUnary(ctx, req)
}

// GetQueueInfo calls fluxmq.queue.v1.QueueService.GetQueueInfo.
func (c *queueServiceClient) GetQueueInfo(ctx context.Context, req *connect.Request[v1.GetQueueInfoRequest]) (*connect.Response[v1.QueueInfo], error) {
	return c.getQueueInfo.CallUnary(ctx, req)
}

// GetStats calls fluxmq.queue.v1.QueueService.GetStats.
func (c *queueServiceClient) GetStats(ctx context.Context, req *connect.Request[v1.GetStatsRequest]) (*connect.Response[v1.QueueStats], error) {
	return c.getStats.CallUnary(ctx, req)
}

// Purge calls fluxmq.queue.v1.QueueService.Purge.
func (c *queueServiceClient) Purge(ctx context.Context, req *connect.Request[v1.PurgeRequest]) (*connect.Response[v1.PurgeResponse], error) {
	return c.purge.CallUnary(ctx, req)
}

// Truncate calls fluxmq.queue.v1.QueueService.Truncate.
func (c *queueServiceClient) Truncate(ctx context.Context, req *connect.Request[v1.TruncateRequest]) (*connect.Response[emptypb.Empty], error) {
	return c.truncate.CallUnary(ctx, req)
}

// QueueServiceHandler is an implementation of the fluxmq.queue.v1.QueueService service.
type QueueServiceHandler interface {
	// CreateQueue creates a new queue with the specified configuration.
	CreateQueue(context.Context, *connect.Request[v1.CreateQueueRequest]) (*connect.Response[v1.Queue], error)
	// GetQueue retrieves queue metadata and current state.
	GetQueue(context.Context, *connect.Request[v1.GetQueueRequest]) (*connect.Response[v1.Queue], error)
	// ListQueues returns all queues, with optional filtering.
	ListQueues(context.Context, *connect.Request[v1.ListQueuesRequest]) (*connect.Response[v1.ListQueuesResponse], error)
	// DeleteQueue removes a queue and all its data.
	DeleteQueue(context.Context, *connect.Request[v1.DeleteQueueRequest]) (*connect.Response[emptypb.Empty], error)
	// UpdateQueue updates queue configuration (retention, limits, etc).
	UpdateQueue(context.Context, *connect.Request[v1.UpdateQueueRequest]) (*connect.Response[v1.Queue], error)
	// Append adds a single message to a queue. Returns the assigned offset.
	Append(context.Context, *connect.Request[v1.AppendRequest]) (*connect.Response[v1.AppendResponse], error)
	// AppendBatch adds multiple messages atomically.
	AppendBatch(context.Context, *connect.Request[v1.AppendBatchRequest]) (*connect.Response[v1.AppendBatchResponse], error)
	// AppendStream allows streaming multiple messages.
	AppendStream(context.Context, *connect.ClientStream[v1.AppendRequest]) (*connect.Response[v1.AppendBatchResponse], error)
	// Read fetches a single message at a specific offset.
	Read(context.Context, *connect.Request[v1.ReadRequest]) (*connect.Response[v1.Message], error)
	// ReadBatch fetches multiple messages starting from an offset.
	ReadBatch(context.Context, *connect.Request[v1.ReadBatchRequest]) (*connect.Response[v1.ReadBatchResponse], error)
	// Tail streams new messages as they arrive (server-side streaming).
	// Starts from specified offset and continues indefinitely.
	Tail(context.Context, *connect.Request[v1.TailRequest], *connect.ServerStream[v1.Message]) error
	// SeekToOffset returns queue state at a given offset.
	SeekToOffset(context.Context, *connect.Request[v1.SeekToOffsetRequest]) (*connect.Response[v1.SeekResponse], error)
	// SeekToTimestamp finds the offset closest to a timestamp.
	SeekToTimestamp(context.Context, *connect.Request[v1.SeekToTimestampRequest]) (*connect.Response[v1.SeekResponse], error)
	// CreateConsumerGroup creates a new consumer group for a queue.
	CreateConsumerGroup(context.Context, *connect.Request[v1.CreateConsumerGroupRequest]) (*connect.Response[v1.ConsumerGroup], error)
	// GetConsumerGroup retrieves consumer group state.
	GetConsumerGroup(context.Context, *connect.Request[v1.GetConsumerGroupRequest]) (*connect.Response[v1.ConsumerGroup], error)
	// ListConsumerGroups lists all consumer groups for a queue.
	ListConsumerGroups(context.Context, *connect.Request[v1.ListConsumerGroupsRequest]) (*connect.Response[v1.ListConsumerGroupsResponse], error)
	// DeleteConsumerGroup removes a consumer group.
	DeleteConsumerGroup(context.Context, *connect.Request[v1.DeleteConsumerGroupRequest]) (*connect.Response[emptypb.Empty], error)
	// JoinGroup adds a consumer to a group.
	JoinGroup(context.Context, *connect.Request[v1.JoinGroupRequest]) (*connect.Response[v1.JoinGroupResponse], error)
	// LeaveGroup removes a consumer from a group.
	LeaveGroup(context.Context, *connect.Request[v1.LeaveGroupRequest]) (*connect.Response[emptypb.Empty], error)
	// Heartbeat keeps consumer session alive and receives rebalance notifications.
	Heartbeat(context.Context, *connect.Request[v1.HeartbeatRequest]) (*connect.Response[v1.HeartbeatResponse], error)
	// Consume fetches the next batch of messages for a consumer.
	// Messages are tracked in the Pending Entry List (PEL) until acknowledged.
	Consume(context.Context, *connect.Request[v1.ConsumeRequest]) (*connect.Response[v1.ConsumeResponse], error)
	// ConsumeStream continuously delivers messages to a consumer (server streaming).
	ConsumeStream(context.Context, *connect.Request[v1.ConsumeStreamRequest], *connect.ServerStream[v1.Message]) error
	// Ack acknowledges successful processing of messages.
	Ack(context.Context, *connect.Request[v1.AckRequest]) (*connect.Response[v1.AckResponse], error)
	// Nack indicates processing failure. Messages will be redelivered.
	Nack(context.Context, *connect.Request[v1.NackRequest]) (*connect.Response[emptypb.Empty], error)
	// Claim transfers pending messages from one consumer to another (work stealing).
	Claim(context.Context, *connect.Request[v1.ClaimRequest]) (*connect.Response[v1.ClaimResponse], error)
	// GetPending retrieves pending (unacknowledged) messages for a consumer or group.
	GetPending(context.Context, *connect.Request[v1.GetPendingRequest]) (*connect.Response[v1.GetPendingResponse], error)
	// GetQueueInfo returns metadata for a queue.
	GetQueueInfo(context.Context, *connect.Request[v1.GetQueueInfoRequest]) (*connect.Response[v1.QueueInfo], error)
	// GetStats returns queue statistics.
	GetStats(context.Context, *connect.Request[v1.GetStatsRequest]) (*connect.Response[v1.QueueStats], error)
	// Purge removes all messages from a queue.
	Purge(context.Context, *connect.Request[v1.PurgeRequest]) (*connect.Response[v1.PurgeResponse], error)
	// Truncate removes messages before a given offset (retention enforcement).
	Truncate(context.Context, *connect.Request[v1.TruncateRequest]) (*connect.Response[emptypb.Empty], error)
}

// NewQueueServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewQueueServiceHandler(svc QueueServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	queueServiceMethods := v1.File_queue_v1_queue_proto.Services().ByName("QueueService").Methods()
	queueServiceCreateQueueHandler := connect.NewUnaryHandler(
		QueueServiceCreateQueueProcedure,
		svc.CreateQueue,
		connect.WithSchema(queueServiceMethods.ByName("CreateQueue")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceGetQueueHandler := connect.NewUnaryHandler(
		QueueServiceGetQueueProcedure,
		svc.GetQueue,
		connect.WithSchema(queueServiceMethods.ByName("GetQueue")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceListQueuesHandler := connect.NewUnaryHandler(
		QueueServiceListQueuesProcedure,
		svc.ListQueues,
		connect.WithSchema(queueServiceMethods.ByName("ListQueues")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceDeleteQueueHandler := connect.NewUnaryHandler(
		QueueServiceDeleteQueueProcedure,
		svc.DeleteQueue,
		connect.WithSchema(queueServiceMethods.ByName("DeleteQueue")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceUpdateQueueHandler := connect.NewUnaryHandler(
		QueueServiceUpdateQueueProcedure,
		svc.UpdateQueue,
		connect.WithSchema(queueServiceMethods.ByName("UpdateQueue")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceAppendHandler := connect.NewUnaryHandler(
		QueueServiceAppendProcedure,
		svc.Append,
		connect.WithSchema(queueServiceMethods.ByName("Append")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceAppendBatchHandler := connect.NewUnaryHandler(
		QueueServiceAppendBatchProcedure,
		svc.AppendBatch,
		connect.WithSchema(queueServiceMethods.ByName("AppendBatch")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceAppendStreamHandler := connect.NewClientStreamHandler(
		QueueServiceAppendStreamProcedure,
		svc.AppendStream,
		connect.WithSchema(queueServiceMethods.ByName("AppendStream")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceReadHandler := connect.NewUnaryHandler(
		QueueServiceReadProcedure,
		svc.Read,
		connect.WithSchema(queueServiceMethods.ByName("Read")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceReadBatchHandler := connect.NewUnaryHandler(
		QueueServiceReadBatchProcedure,
		svc.ReadBatch,
		connect.WithSchema(queueServiceMethods.ByName("ReadBatch")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceTailHandler := connect.NewServerStreamHandler(
		QueueServiceTailProcedure,
		svc.Tail,
		connect.WithSchema(queueServiceMethods.ByName("Tail")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceSeekToOffsetHandler := connect.NewUnaryHandler(
		QueueServiceSeekToOffsetProcedure,
		svc.SeekToOffset,
		connect.WithSchema(queueServiceMethods.ByName("SeekToOffset")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceSeekToTimestampHandler := connect.NewUnaryHandler(
		QueueServiceSeekToTimestampProcedure,
		svc.SeekToTimestamp,
		connect.WithSchema(queueServiceMethods.ByName("SeekToTimestamp")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceCreateConsumerGroupHandler := connect.NewUnaryHandler(
		QueueServiceCreateConsumerGroupProcedure,
		svc.CreateConsumerGroup,
		connect.WithSchema(queueServiceMethods.ByName("CreateConsumerGroup")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceGetConsumerGroupHandler := connect.NewUnaryHandler(
		QueueServiceGetConsumerGroupProcedure,
		svc.GetConsumerGroup,
		connect.WithSchema(queueServiceMethods.ByName("GetConsumerGroup")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceListConsumerGroupsHandler := connect.NewUnaryHandler(
		QueueServiceListConsumerGroupsProcedure,
		svc.ListConsumerGroups,
		connect.WithSchema(queueServiceMethods.ByName("ListConsumerGroups")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceDeleteConsumerGroupHandler := connect.NewUnaryHandler(
		QueueServiceDeleteConsumerGroupProcedure,
		svc.DeleteConsumerGroup,
		connect.WithSchema(queueServiceMethods.ByName("DeleteConsumerGroup")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceJoinGroupHandler := connect.NewUnaryHandler(
		QueueServiceJoinGroupProcedure,
		svc.JoinGroup,
		connect.WithSchema(queueServiceMethods.ByName("JoinGroup")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceLeaveGroupHandler := connect.NewUnaryHandler(
		QueueServiceLeaveGroupProcedure,
		svc.LeaveGroup,
		connect.WithSchema(queueServiceMethods.ByName("LeaveGroup")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceHeartbeatHandler := connect.NewUnaryHandler(
		QueueServiceHeartbeatProcedure,
		svc.Heartbeat,
		connect.WithSchema(queueServiceMethods.ByName("Heartbeat")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceConsumeHandler := connect.NewUnaryHandler(
		QueueServiceConsumeProcedure,
		svc.Consume,
		connect.WithSchema(queueServiceMethods.ByName("Consume")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceConsumeStreamHandler := connect.NewServerStreamHandler(
		QueueServiceConsumeStreamProcedure,
		svc.ConsumeStream,
		connect.WithSchema(queueServiceMethods.ByName("ConsumeStream")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceAckHandler := connect.NewUnaryHandler(
		QueueServiceAckProcedure,
		svc.Ack,
		connect.WithSchema(queueServiceMethods.ByName("Ack")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceNackHandler := connect.NewUnaryHandler(
		QueueServiceNackProcedure,
		svc.Nack,
		connect.WithSchema(queueServiceMethods.ByName("Nack")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceClaimHandler := connect.NewUnaryHandler(
		QueueServiceClaimProcedure,
		svc.Claim,
		connect.WithSchema(queueServiceMethods.ByName("Claim")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceGetPendingHandler := connect.NewUnaryHandler(
		QueueServiceGetPendingProcedure,
		svc.GetPending,
		connect.WithSchema(queueServiceMethods.ByName("GetPending")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceGetQueueInfoHandler := connect.NewUnaryHandler(
		QueueServiceGetQueueInfoProcedure,
		svc.GetQueueInfo,
		connect.WithSchema(queueServiceMethods.ByName("GetQueueInfo")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceGetStatsHandler := connect.NewUnaryHandler(
		QueueServiceGetStatsProcedure,
		svc.GetStats,
		connect.WithSchema(queueServiceMethods.ByName("GetStats")),
		connect.WithHandlerOptions(opts...),
	)
	queueServicePurgeHandler := connect.NewUnaryHandler(
		QueueServicePurgeProcedure,
		svc.Purge,
		connect.WithSchema(queueServiceMethods.ByName("Purge")),
		connect.WithHandlerOptions(opts...),
	)
	queueServiceTruncateHandler := connect.NewUnaryHandler(
		QueueServiceTruncateProcedure,
		svc.Truncate,
		connect.WithSchema(queueServiceMethods.ByName("Truncate")),
		connect.WithHandlerOptions(opts...),
	)
	return "/fluxmq.queue.v1.QueueService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case QueueServiceCreateQueueProcedure:
			queueServiceCreateQueueHandler.ServeHTTP(w, r)
		case QueueServiceGetQueueProcedure:
			queueServiceGetQueueHandler.ServeHTTP(w, r)
		case QueueServiceListQueuesProcedure:
			queueServiceListQueuesHandler.ServeHTTP(w, r)
		case QueueServiceDeleteQueueProcedure:
			queueServiceDeleteQueueHandler.ServeHTTP(w, r)
		case QueueServiceUpdateQueueProcedure:
			queueServiceUpdateQueueHandler.ServeHTTP(w, r)
		case QueueServiceAppendProcedure:
			queueServiceAppendHandler.ServeHTTP(w, r)
		case QueueServiceAppendBatchProcedure:
			queueServiceAppendBatchHandler.ServeHTTP(w, r)
		case QueueServiceAppendStreamProcedure:
			queueServiceAppendStreamHandler.ServeHTTP(w, r)
		case QueueServiceReadProcedure:
			queueServiceReadHandler.ServeHTTP(w, r)
		case QueueServiceReadBatchProcedure:
			queueServiceReadBatchHandler.ServeHTTP(w, r)
		case QueueServiceTailProcedure:
			queueServiceTailHandler.ServeHTTP(w, r)
		case QueueServiceSeekToOffsetProcedure:
			queueServiceSeekToOffsetHandler.ServeHTTP(w, r)
		case QueueServiceSeekToTimestampProcedure:
			queueServiceSeekToTimestampHandler.ServeHTTP(w, r)
		case QueueServiceCreateConsumerGroupProcedure:
			queueServiceCreateConsumerGroupHandler.ServeHTTP(w, r)
		case QueueServiceGetConsumerGroupProcedure:
			queueServiceGetConsumerGroupHandler.ServeHTTP(w, r)
		case QueueServiceListConsumerGroupsProcedure:
			queueServiceListConsumerGroupsHandler.ServeHTTP(w, r)
		case QueueServiceDeleteConsumerGroupProcedure:
			queueServiceDeleteConsumerGroupHandler.ServeHTTP(w, r)
		case QueueServiceJoinGroupProcedure:
			queueServiceJoinGroupHandler.ServeHTTP(w, r)
		case QueueServiceLeaveGroupProcedure:
			queueServiceLeaveGroupHandler.ServeHTTP(w, r)
		case QueueServiceHeartbeatProcedure:
			queueServiceHeartbeatHandler.ServeHTTP(w, r)
		case QueueServiceConsumeProcedure:
			queueServiceConsumeHandler.ServeHTTP(w, r)
		case QueueServiceConsumeStreamProcedure:
			queueServiceConsumeStreamHandler.ServeHTTP(w, r)
		case QueueServiceAckProcedure:
			queueServiceAckHandler.ServeHTTP(w, r)
		case QueueServiceNackProcedure:
			queueServiceNackHandler.ServeHTTP(w, r)
		case QueueServiceClaimProcedure:
			queueServiceClaimHandler.ServeHTTP(w, r)
		case QueueServiceGetPendingProcedure:
			queueServiceGetPendingHandler.ServeHTTP(w, r)
		case QueueServiceGetQueueInfoProcedure:
			queueServiceGetQueueInfoHandler.ServeHTTP(w, r)
		case QueueServiceGetStatsProcedure:
			queueServiceGetStatsHandler.ServeHTTP(w, r)
		case QueueServicePurgeProcedure:
			queueServicePurgeHandler.ServeHTTP(w, r)
		case QueueServiceTruncateProcedure:
			queueServiceTruncateHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedQueueServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedQueueServiceHandler struct{}

func (UnimplementedQueueServiceHandler) CreateQueue(context.Context, *connect.Request[v1.CreateQueueRequest]) (*connect.Response[v1.Queue], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.CreateQueue is not implemented"))
}

func (UnimplementedQueueServiceHandler) GetQueue(context.Context, *connect.Request[v1.GetQueueRequest]) (*connect.Response[v1.Queue], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.GetQueue is not implemented"))
}

func (UnimplementedQueueServiceHandler) ListQueues(context.Context, *connect.Request[v1.ListQueuesRequest]) (*connect.Response[v1.ListQueuesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.ListQueues is not implemented"))
}

func (UnimplementedQueueServiceHandler) DeleteQueue(context.Context, *connect.Request[v1.DeleteQueueRequest]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.DeleteQueue is not implemented"))
}

func (UnimplementedQueueServiceHandler) UpdateQueue(context.Context, *connect.Request[v1.UpdateQueueRequest]) (*connect.Response[v1.Queue], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.UpdateQueue is not implemented"))
}

func (UnimplementedQueueServiceHandler) Append(context.Context, *connect.Request[v1.AppendRequest]) (*connect.Response[v1.AppendResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.Append is not implemented"))
}

func (UnimplementedQueueServiceHandler) AppendBatch(context.Context, *connect.Request[v1.AppendBatchRequest]) (*connect.Response[v1.AppendBatchResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.AppendBatch is not implemented"))
}

func (UnimplementedQueueServiceHandler) AppendStream(context.Context, *connect.ClientStream[v1.AppendRequest]) (*connect.Response[v1.AppendBatchResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.AppendStream is not implemented"))
}

func (UnimplementedQueueServiceHandler) Read(context.Context, *connect.Request[v1.ReadRequest]) (*connect.Response[v1.Message], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.Read is not implemented"))
}

func (UnimplementedQueueServiceHandler) ReadBatch(context.Context, *connect.Request[v1.ReadBatchRequest]) (*connect.Response[v1.ReadBatchResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.ReadBatch is not implemented"))
}

func (UnimplementedQueueServiceHandler) Tail(context.Context, *connect.Request[v1.TailRequest], *connect.ServerStream[v1.Message]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.Tail is not implemented"))
}

func (UnimplementedQueueServiceHandler) SeekToOffset(context.Context, *connect.Request[v1.SeekToOffsetRequest]) (*connect.Response[v1.SeekResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.SeekToOffset is not implemented"))
}

func (UnimplementedQueueServiceHandler) SeekToTimestamp(context.Context, *connect.Request[v1.SeekToTimestampRequest]) (*connect.Response[v1.SeekResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.SeekToTimestamp is not implemented"))
}

func (UnimplementedQueueServiceHandler) CreateConsumerGroup(context.Context, *connect.Request[v1.CreateConsumerGroupRequest]) (*connect.Response[v1.ConsumerGroup], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.CreateConsumerGroup is not implemented"))
}

func (UnimplementedQueueServiceHandler) GetConsumerGroup(context.Context, *connect.Request[v1.GetConsumerGroupRequest]) (*connect.Response[v1.ConsumerGroup], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.GetConsumerGroup is not implemented"))
}

func (UnimplementedQueueServiceHandler) ListConsumerGroups(context.Context, *connect.Request[v1.ListConsumerGroupsRequest]) (*connect.Response[v1.ListConsumerGroupsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.ListConsumerGroups is not implemented"))
}

func (UnimplementedQueueServiceHandler) DeleteConsumerGroup(context.Context, *connect.Request[v1.DeleteConsumerGroupRequest]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.DeleteConsumerGroup is not implemented"))
}

func (UnimplementedQueueServiceHandler) JoinGroup(context.Context, *connect.Request[v1.JoinGroupRequest]) (*connect.Response[v1.JoinGroupResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.JoinGroup is not implemented"))
}

func (UnimplementedQueueServiceHandler) LeaveGroup(context.Context, *connect.Request[v1.LeaveGroupRequest]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.LeaveGroup is not implemented"))
}

func (UnimplementedQueueServiceHandler) Heartbeat(context.Context, *connect.Request[v1.HeartbeatRequest]) (*connect.Response[v1.HeartbeatResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.Heartbeat is not implemented"))
}

func (UnimplementedQueueServiceHandler) Consume(context.Context, *connect.Request[v1.ConsumeRequest]) (*connect.Response[v1.ConsumeResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.Consume is not implemented"))
}

func (UnimplementedQueueServiceHandler) ConsumeStream(context.Context, *connect.Request[v1.ConsumeStreamRequest], *connect.ServerStream[v1.Message]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.ConsumeStream is not implemented"))
}

func (UnimplementedQueueServiceHandler) Ack(context.Context, *connect.Request[v1.AckRequest]) (*connect.Response[v1.AckResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.Ack is not implemented"))
}

func (UnimplementedQueueServiceHandler) Nack(context.Context, *connect.Request[v1.NackRequest]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.Nack is not implemented"))
}

func (UnimplementedQueueServiceHandler) Claim(context.Context, *connect.Request[v1.ClaimRequest]) (*connect.Response[v1.ClaimResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.Claim is not implemented"))
}

func (UnimplementedQueueServiceHandler) GetPending(context.Context, *connect.Request[v1.GetPendingRequest]) (*connect.Response[v1.GetPendingResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.GetPending is not implemented"))
}

func (UnimplementedQueueServiceHandler) GetQueueInfo(context.Context, *connect.Request[v1.GetQueueInfoRequest]) (*connect.Response[v1.QueueInfo], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.GetQueueInfo is not implemented"))
}

func (UnimplementedQueueServiceHandler) GetStats(context.Context, *connect.Request[v1.GetStatsRequest]) (*connect.Response[v1.QueueStats], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.GetStats is not implemented"))
}

func (UnimplementedQueueServiceHandler) Purge(context.Context, *connect.Request[v1.PurgeRequest]) (*connect.Response[v1.PurgeResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.Purge is not implemented"))
}

func (UnimplementedQueueServiceHandler) Truncate(context.Context, *connect.Request[v1.TruncateRequest]) (*connect.Response[emptypb.Empty], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("fluxmq.queue.v1.QueueService.Truncate is not implemented"))
}
