syntax = "proto3";

package cluster;

option go_package = "github.com/absmach/mqtt/cluster/grpc";

// BrokerService defines RPC methods for inter-broker communication in the cluster.
service BrokerService {
  // RoutePublish forwards a PUBLISH packet to the broker that owns the target session.
  rpc RoutePublish(PublishRequest) returns (PublishResponse);

  // TakeoverSession migrates a session from one broker to another.
  rpc TakeoverSession(TakeoverRequest) returns (TakeoverResponse);

  // FetchRetained fetches a retained message payload from the owning broker node.
  // Used when a large retained message (above threshold) needs to be delivered to a subscriber on a different node.
  rpc FetchRetained(FetchRetainedRequest) returns (FetchRetainedResponse);

  // FetchWill fetches a will message payload from the owning broker node.
  // Used when a large will message (above threshold) needs to be published after client disconnect.
  rpc FetchWill(FetchWillRequest) returns (FetchWillResponse);

  // EnqueueRemote routes an enqueue operation to the partition owner node.
  // Used in distributed queue mode when a message needs to be enqueued on a remote partition.
  rpc EnqueueRemote(EnqueueRemoteRequest) returns (EnqueueRemoteResponse);

  // RouteQueueMessage delivers a queue message to a consumer on a different node.
  // Used when partition owner needs to deliver to a consumer connected to another node.
  rpc RouteQueueMessage(RouteQueueMessageRequest) returns (RouteQueueMessageResponse);

  // Raft RPCs for queue partition replication

  // AppendEntries is invoked by the Raft leader to replicate log entries.
  // Also used as a heartbeat to maintain leadership.
  rpc AppendEntries(AppendEntriesRequest) returns (AppendEntriesResponse);

  // RequestVote is invoked by candidates during leader election.
  rpc RequestVote(RequestVoteRequest) returns (RequestVoteResponse);

  // InstallSnapshot is invoked by leader to transfer snapshot to a follower.
  rpc InstallSnapshot(InstallSnapshotRequest) returns (InstallSnapshotResponse);
}

// PublishRequest contains a serialized PUBLISH packet to route to a client.
message PublishRequest {
  string client_id = 1;           // Target client ID
  string topic = 2;               // MQTT topic
  bytes payload = 3;              // Message payload
  uint32 qos = 4;                 // QoS level (0, 1, 2)
  bool retain = 5;                // Retain flag
  bool dup = 6;                   // Duplicate flag
  map<string, string> properties = 7; // MQTT v5 properties (if any)
}

// PublishResponse indicates whether the publish was delivered.
message PublishResponse {
  bool success = 1;
  string error = 2;  // Error message if success=false
}

// TakeoverRequest requests session migration from one node to another.
message TakeoverRequest {
  string client_id = 1;
  string from_node = 2;  // Node currently owning the session
  string to_node = 3;    // Node taking over the session
}

// SessionState contains the full state of an MQTT session.
message SessionState {
  uint32 expiry_interval = 1;
  bool clean_start = 2;

  // In-flight messages (QoS 1/2 not yet acknowledged)
  repeated InflightMessage inflight_messages = 3;

  // Offline queue (messages waiting for delivery)
  repeated QueuedMessage queued_messages = 4;

  // Subscriptions
  repeated Subscription subscriptions = 5;

  // Will message
  WillMessage will = 6;
}

// InflightMessage represents a message awaiting acknowledgment.
message InflightMessage {
  uint32 packet_id = 1;
  string topic = 2;
  bytes payload = 3;
  uint32 qos = 4;
  bool retain = 5;
  int64 timestamp = 6;
}

// QueuedMessage represents a message in the offline queue.
message QueuedMessage {
  string topic = 1;
  bytes payload = 2;
  uint32 qos = 3;
  bool retain = 4;
  int64 timestamp = 5;
}

// Subscription represents a topic subscription.
message Subscription {
  string filter = 1;
  uint32 qos = 2;
}

// WillMessage represents a last will and testament.
message WillMessage {
  string topic = 1;
  bytes payload = 2;
  uint32 qos = 3;
  bool retain = 4;
  uint32 delay = 5;
  int64 disconnect_time = 6;
}

// TakeoverResponse indicates whether the takeover succeeded and returns session state.
message TakeoverResponse {
  bool success = 1;
  string error = 2;

  // Session state transferred from the old node
  SessionState session_state = 3;
}

// FetchRetainedRequest requests a retained message from the owning node.
message FetchRetainedRequest {
  string topic = 1;  // Topic of the retained message to fetch
}

// RetainedMessage represents a complete retained message with all properties.
message RetainedMessage {
  string topic = 1;
  bytes payload = 2;
  uint32 qos = 3;
  bool retain = 4;
  map<string, string> properties = 5;  // MQTT v5 properties
  int64 timestamp = 6;                 // When the message was retained
}

// FetchRetainedResponse returns the retained message if found.
message FetchRetainedResponse {
  bool found = 1;                         // True if message exists
  RetainedMessage message = 2;            // The retained message (only if found=true)
  string error = 3;                       // Error message if request failed
}

// FetchWillRequest requests a will message from the owning node.
message FetchWillRequest {
  string client_id = 1;  // Client ID whose will message to fetch
}

// FetchWillResponse returns the will message if found.
message FetchWillResponse {
  bool found = 1;            // True if will message exists
  WillMessage message = 2;   // The will message (only if found=true)
  string error = 3;          // Error message if request failed
}

// EnqueueRemoteRequest requests enqueueing a message on a remote partition owner.
message EnqueueRemoteRequest {
  string queue_name = 1;                  // Queue topic name
  bytes payload = 2;                      // Message payload
  map<string, string> properties = 3;     // Message properties (including partition-key)
}

// EnqueueRemoteResponse indicates whether the enqueue succeeded.
message EnqueueRemoteResponse {
  bool success = 1;
  string error = 2;          // Error message if success=false
  string message_id = 3;     // Generated message ID
}

// RouteQueueMessageRequest delivers a queue message to a consumer on another node.
message RouteQueueMessageRequest {
  string client_id = 1;                   // Target consumer client ID
  string queue_name = 2;                  // Queue name
  string message_id = 3;                  // Message ID
  bytes payload = 4;                      // Message payload
  map<string, string> properties = 5;     // Message properties
  int64 sequence = 6;                     // Message sequence number
  int32 partition_id = 7;                 // Partition ID
}

// RouteQueueMessageResponse indicates whether the delivery succeeded.
message RouteQueueMessageResponse {
  bool success = 1;
  string error = 2;          // Error message if success=false
}

// Raft RPC messages

// AppendEntriesRequest is sent by the leader to replicate log entries.
message AppendEntriesRequest {
  string queue_name = 1;      // Queue name for routing
  int32 partition_id = 2;     // Partition ID for routing
  uint64 term = 3;            // Leader's term
  string leader_id = 4;       // Leader's node ID
  uint64 prev_log_index = 5;  // Index of log entry immediately preceding new ones
  uint64 prev_log_term = 6;   // Term of prev_log_index entry
  repeated bytes entries = 7;  // Log entries to store (serialized)
  uint64 leader_commit = 8;   // Leader's commit index
}

// AppendEntriesResponse is the response to AppendEntries.
message AppendEntriesResponse {
  uint64 term = 1;            // Current term, for leader to update itself
  bool success = 2;           // True if follower contained entry matching prev_log_index and prev_log_term
  uint64 last_log_index = 3;  // Follower's last log index (for leader to update next_index)
}

// RequestVoteRequest is sent by candidates during leader election.
message RequestVoteRequest {
  string queue_name = 1;      // Queue name for routing
  int32 partition_id = 2;     // Partition ID for routing
  uint64 term = 3;            // Candidate's term
  string candidate_id = 4;    // Candidate's node ID
  uint64 last_log_index = 5;  // Index of candidate's last log entry
  uint64 last_log_term = 6;   // Term of candidate's last log entry
}

// RequestVoteResponse is the response to RequestVote.
message RequestVoteResponse {
  uint64 term = 1;            // Current term, for candidate to update itself
  bool vote_granted = 2;      // True if candidate received vote
}

// InstallSnapshotRequest is sent by leader to transfer snapshot to follower.
message InstallSnapshotRequest {
  string queue_name = 1;      // Queue name for routing
  int32 partition_id = 2;     // Partition ID for routing
  uint64 term = 3;            // Leader's term
  string leader_id = 4;       // Leader's node ID
  uint64 last_included_index = 5;  // Snapshot replaces all entries up through this index
  uint64 last_included_term = 6;   // Term of last_included_index
  bytes data = 7;             // Snapshot data (chunk)
  bool done = 8;              // True if this is the last chunk
}

// InstallSnapshotResponse is the response to InstallSnapshot.
message InstallSnapshotResponse {
  uint64 term = 1;            // Current term, for leader to update itself
}
