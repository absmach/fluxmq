server:
  tcp:
    plain:
      addr: ":1883" # "<host>:<port>" or ":<port>"; empty string disables this listener.
      max_connections: 10000 # >= 0; 0 means no connection cap.
      read_timeout: 60s # Go duration (e.g. 30s, 1m).
      write_timeout: 60s # Go duration.
    tls:
      addr: "" # Set to enable MQTT over TLS.
      max_connections: 10000 # >= 0; 0 means no connection cap.
      read_timeout: 60s # Go duration.
      write_timeout: 60s # Go duration.
    mtls:
      addr: "" # Set to enable MQTT over mutual TLS.
      max_connections: 10000 # >= 0; 0 means no connection cap.
      read_timeout: 60s # Go duration.
      write_timeout: 60s # Go duration.
  websocket:
    plain:
      addr: "" # "<host>:<port>" or ":<port>"; empty string disables this listener.
      path: "/mqtt" # HTTP path for MQTT over WebSocket.
      allowed_origins: [] # [] allows all; use ["*"] wildcard or explicit origins like ["https://app.example.com"].
    tls:
      addr: "" # Set to enable WSS listener.
      path: "/mqtt" # HTTP path for MQTT over WebSocket.
      allowed_origins: [] # [] allows all; use ["*"] or explicit origins.
    mtls:
      addr: "" # Set to enable mutual TLS WSS listener.
      path: "/mqtt" # HTTP path for MQTT over WebSocket.
      allowed_origins: [] # [] allows all; use ["*"] or explicit origins.
  http:
    plain:
      addr: "" # "<host>:<port>" or ":<port>"; empty string disables HTTP bridge.
    tls:
      addr: "" # Set to enable HTTPS bridge.
    mtls:
      addr: "" # Set to enable mutual TLS HTTPS bridge.
  coap:
    plain:
      addr: "" # "<host>:<port>" or ":<port>"; empty string disables CoAP bridge.
    dtls:
      addr: "" # Set to enable CoAP over DTLS.
    mdtls:
      addr: "" # Set to enable CoAP over mutual DTLS.
  amqp:
    plain:
      addr: ":5672" # "<host>:<port>" or ":<port>"; empty string disables this listener.
      max_connections: 10000 # >= 0; 0 means no connection cap.
    tls:
      addr: "" # Set to enable AMQP over TLS.
      max_connections: 10000 # >= 0; 0 means no connection cap.
    mtls:
      addr: "" # Set to enable AMQP over mutual TLS.
      max_connections: 10000 # >= 0; 0 means no connection cap.
  amqp091:
    plain:
      addr: ":5682" # "<host>:<port>" or ":<port>"; empty string disables this listener.
      max_connections: 10000 # >= 0; 0 means no connection cap.
    tls:
      addr: "" # Set to enable AMQP 0.9.1 over TLS.
      max_connections: 10000 # >= 0; 0 means no connection cap.
    mtls:
      addr: "" # Set to enable AMQP 0.9.1 over mutual TLS.
      max_connections: 10000 # >= 0; 0 means no connection cap.
  health_addr: ":8081" # Health endpoint bind address (used when health_enabled=true).
  metrics_addr: "localhost:4317" # OTLP endpoint address used when metrics_enabled=true.
  shutdown_timeout: 30s # Graceful shutdown timeout (Go duration).
  health_enabled: true # true|false.
  metrics_enabled: false # true|false; enables OpenTelemetry pipeline.
  otel_service_name: "fluxmq" # Non-empty service name for telemetry.
  otel_service_version: "1.0.0" # Service version tag reported in telemetry.
  otel_traces_enabled: false # true|false.
  otel_metrics_enabled: true # true|false.
  otel_trace_sample_rate: 0.1 # 0.0..1.0 (e.g. 0=no traces, 1=sample all).
  api_enabled: false # true|false; enables queue API server.
  api_addr: "" # "<host>:<port>" when api_enabled=true.

broker:
  max_message_size: 1048576 # Bytes; must be >= 1024.
  max_retained_messages: 10000 # Maximum retained messages kept in storage.
  retry_interval: 20s # Go duration; QoS 1/2 retry interval (>= 1s).
  max_retries: 0 # >= 0; 0 means unlimited retries.
  max_qos: 2 # Allowed values: 0, 1, 2.
  # async_fan_out decouples subscriber distribution from the publisher PUBREL/PUBCOMP handshake.
  # true = PUBCOMP immediately, fan-out in worker pool; false = synchronous fan-out.
  async_fan_out: true
  fan_out_workers: 0 # >= 0; 0 = GOMAXPROCS (used when async_fan_out=true).

session:
  max_sessions: 10000 # >= 1.
  default_expiry_interval: 300 # Seconds; MQTT session expiry when client does not set one.
  max_offline_queue_size: 10000 # >= 10; max queued QoS 1/2 messages per offline client.
  max_inflight_messages: 1000 # Per-session inflight window (unacked outbound QoS 1/2).
  max_send_queue_size: 1000 # >= 0; 0=synchronous writes, >0=async send queue depth.
  offline_queue_policy: "evict" # Allowed values: "evict" (drop oldest), "reject" (drop new).
  # inflight_overflow controls behavior when a subscriber inflight window is full.
  # 0 = backpressure (block until ACK), 1 = pending queue (buffer then drain on ACK).
  inflight_overflow: 1
  pending_queue_size: 1000 # >= 1 when inflight_overflow=1.

log:
  level: "info" # Allowed values: "debug", "info", "warn", "error".
  format: "text" # Allowed values: "text", "json".

storage:
  type: "badger" # Allowed values: "memory", "badger".
  badger_dir: "/data/node1/data" # Required when type="badger".
  sync_writes: false # true|false; true favors durability, false favors throughput.

cluster:
  enabled: true # true|false.
  node_id: "node1" # Unique node identifier in the cluster.
  etcd:
    data_dir: "/data/node1/etcd" # Local etcd data directory.
    bind_addr: "10.247.0.11:2380" # etcd peer address for intra-cluster replication.
    client_addr: "10.247.0.11:2379" # etcd client address used by this broker.
    initial_cluster: "node1=http://10.247.0.11:2380,node2=http://10.247.0.12:2380,node3=http://10.247.0.13:2380" # Comma-separated "name=http://host:2380" entries for all members.
    bootstrap: true # true for cluster bootstrap/startup; false for joining existing cluster.
    hybrid_retained_size_threshold: 1024 # Bytes; retained/will payloads <= threshold replicate in etcd.
  transport:
    bind_addr: "10.247.0.11:7948" # Inter-node gRPC transport bind address.
    peers: # Map of node_id -> transport address.
      node2: "10.247.0.12:7948"
      node3: "10.247.0.13:7948"
    route_batch_max_size: 256 # >= 0; flush when this many messages are batched.
    route_batch_max_delay: 50ms # >= 0; max wait before flushing a partial batch.
    route_batch_flush_workers: 8 # >= 0; concurrent flush goroutines per peer.
    route_publish_timeout: 15s # Go duration; 0 uses default (15s).
    tls_enabled: false # true|false.
    tls_cert_file: "" # Required when tls_enabled=true.
    tls_key_file: "" # Required when tls_enabled=true.
    tls_ca_file: "" # Required when tls_enabled=true.
  raft:
    enabled: false # true|false.
    auto_provision_groups: true # true|false; auto-create missing groups referenced by queues.
    replication_factor: 3 # 1..10 when raft is enabled.
    sync_mode: true # true=wait for Raft apply, false=async publish path.
    min_in_sync_replicas: 2 # 1..replication_factor.
    ack_timeout: 5s # > 0 when raft is enabled.
    write_policy: "forward" # Allowed values: "local", "reject", "forward".
    distribution_mode: "replicate" # Allowed values: "forward", "replicate".
    bind_addr: "127.0.0.1:7100" # Required when raft is enabled.
    data_dir: "/tmp/fluxmq/raft" # Required when raft is enabled.
    peers: {} # Map of node_id -> raft bind address.
    heartbeat_timeout: 1s # Go duration; Raft heartbeat tick.
    election_timeout: 3s # Go duration; Raft leader election timeout.
    snapshot_interval: 5m # Go duration; snapshot check/apply interval.
    snapshot_threshold: 8192 # Snapshot trigger threshold in log entries.
    groups: {} # Optional map of group_id -> per-group raft overrides.

webhook:
  enabled: false # true|false.
  queue_size: 10000 # >= 100 when enabled.
  drop_policy: "oldest" # Allowed values: "oldest", "newest".
  workers: 5 # >= 1 worker goroutines.
  include_payload: false # true|false; include message payload in webhook events.
  shutdown_timeout: 30s # >= 1s when enabled.
  defaults:
    timeout: 5s # >= 1s default endpoint timeout.
    retry:
      max_attempts: 3 # >= 1.
      initial_interval: 1s # Go duration.
      max_interval: 30s # Go duration.
      multiplier: 2.0 # >= 1.0 exponential backoff multiplier.
    circuit_breaker:
      failure_threshold: 5 # >= 1 consecutive failures before opening breaker.
      reset_timeout: 60s # Go duration before probing closed state again.
  endpoints: [] # List of endpoint objects (type currently supports "http").

# ratelimit:
#   enabled: false # true|false.
#   connection:
#     enabled: true # true|false.
#     rate: 1.6666666666666667 # Connections/sec/IP.
#     burst: 20 # Token bucket burst.
#     cleanup_interval: 5m # Cleanup interval for stale rate-limit entries.
#   message:
#     enabled: true # true|false.
#     rate: 1000 # Messages/sec/client.
#     burst: 100 # Token bucket burst.
#   subscribe:
#     enabled: true # true|false.
#     rate: 100 # SUBSCRIBE ops/sec/client.
#     burst: 10 # Token bucket burst.

queue_manager:
  auto_commit_interval: 5s # >= 0; 0 commits stream offsets every delivery batch.

queues:
  - name: "mqtt" # Unique queue name.
    topics: # Topic filters routed into this queue.
      - "$queue/#"
    reserved: true # true|false; marks built-in/protected queue config.
    type: "" # Queue mode: "classic" or "stream"; empty uses default behavior.
    primary_group: "" # Stream status reporting group; empty uses default.
    retention:
      max_age: 0s # Go duration; 0s means unlimited by age.
      max_length_bytes: 0 # >= 0 bytes; 0 means unlimited.
      max_length_messages: 0 # >= 0 messages; 0 means unlimited.
    limits:
      max_message_size: 10485760 # Bytes; queue-level publish size cap.
      max_depth: 100000 # Max queued messages before applying retry/DLQ behavior.
      message_ttl: 168h # Go duration; per-message TTL in queue.
    retry:
      max_retries: 10 # >= 0 retries per message.
      initial_backoff: 5s # Go duration.
      max_backoff: 5m # Go duration.
      multiplier: 2.0 # >= 1.0 exponential backoff multiplier.
    dlq:
      enabled: true # true|false.
      topic: "" # Optional DLQ topic override; empty uses default DLQ topic.
    replication:
      enabled: false # true|false; enables per-queue Raft replication.
      group: "" # Group id; empty means "default" group.
      replication_factor: 3 # 1..10 when enabled.
      mode: "sync" # Allowed values: "sync", "async".
      min_in_sync_replicas: 2 # 1..replication_factor when enabled.
      ack_timeout: 5s # > 0 when enabled.
      heartbeat_timeout: 0s # Go duration; 0s inherits cluster.raft heartbeat timeout.
      election_timeout: 0s # Go duration; 0s inherits cluster.raft election timeout.
      snapshot_interval: 0s # Go duration; 0s inherits cluster.raft snapshot interval.
      snapshot_threshold: 0 # >= 0; 0 inherits cluster.raft snapshot threshold.
